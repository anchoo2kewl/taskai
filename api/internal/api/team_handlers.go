package api

import (
	"context"
	"encoding/json"
	"net/http"
	"strconv"
	"time"

	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"

	"taskai/ent"
	"taskai/ent/project"
	"taskai/ent/team"
	"taskai/ent/teammember"
	"taskai/ent/teaminvitation"
	"taskai/ent/user"
)

type Team struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	OwnerID   int64     `json:"owner_id"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

type TeamMember struct {
	ID       int64     `json:"id"`
	TeamID   int64     `json:"team_id"`
	UserID   int64     `json:"user_id"`
	UserName *string   `json:"user_name,omitempty"`
	Email    string    `json:"email"`
	Role     string    `json:"role"`
	Status   string    `json:"status"`
	JoinedAt time.Time `json:"joined_at"`
}

type TeamInvitation struct {
	ID            int64      `json:"id"`
	TeamID        int64      `json:"team_id"`
	TeamName      string     `json:"team_name"`
	InviterID     int64      `json:"inviter_id"`
	InviterName   *string    `json:"inviter_name,omitempty"`
	InviteeEmail  string     `json:"invitee_email"`
	InviteeID     *int64     `json:"invitee_id,omitempty"`
	Status        string     `json:"status"`
	CreatedAt     time.Time  `json:"created_at"`
	RespondedAt   *time.Time `json:"responded_at,omitempty"`
}

type CreateTeamRequest struct {
	Name string `json:"name"`
}

type InviteTeamMemberRequest struct {
	Email string `json:"email"`
}

type UpdateTeamMemberRequest struct {
	Role string `json:"role"`
}

// HandleGetMyTeam returns the current user's team
func (s *Server) HandleGetMyTeam(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)

	// Get user's active team membership
	entTeam, err := s.db.Client.Team.Query().
		Where(team.HasMembersWith(
			teammember.UserID(userID),
			teammember.Status("active"),
		)).
		First(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "no active team found", "not_found")
			return
		}
		s.logger.Error("Failed to get user's team", zap.Error(err), zap.Int64("user_id", userID))
		respondError(w, http.StatusInternalServerError, "failed to fetch team", "internal_error")
		return
	}

	apiTeam := Team{
		ID:        entTeam.ID,
		Name:      entTeam.Name,
		OwnerID:   entTeam.OwnerID,
		CreatedAt: entTeam.CreatedAt,
		UpdatedAt: entTeam.UpdatedAt,
	}

	respondJSON(w, http.StatusOK, apiTeam)
}

// HandleGetTeamMembers returns all members of the user's team
func (s *Server) HandleGetTeamMembers(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)

	// Get user's team ID
	teamID, err := s.getUserTeamID(ctx, userID)
	if err != nil {
		respondError(w, http.StatusNotFound, "no active team found", "not_found")
		return
	}

	// Get all team members with user info
	entMembers, err := s.db.Client.TeamMember.Query().
		Where(teammember.TeamID(teamID)).
		WithUser().
		Order(ent.Desc(teammember.FieldRole), ent.Asc(teammember.FieldJoinedAt)).
		All(ctx)
	if err != nil {
		s.logger.Error("Failed to get team members", zap.Error(err), zap.Int64("team_id", teamID))
		respondError(w, http.StatusInternalServerError, "failed to fetch team members", "internal_error")
		return
	}

	members := make([]TeamMember, 0, len(entMembers))
	for _, em := range entMembers {
		m := TeamMember{
			ID:       em.ID,
			TeamID:   em.TeamID,
			UserID:   em.UserID,
			Role:     em.Role,
			Status:   em.Status,
			JoinedAt: em.JoinedAt,
		}

		if em.Edges.User != nil {
			m.UserName = em.Edges.User.Name
			m.Email = em.Edges.User.Email
		}

		members = append(members, m)
	}

	respondJSON(w, http.StatusOK, members)
}

// HandleInviteTeamMember sends an invitation to join the team
func (s *Server) HandleInviteTeamMember(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)

	var req InviteTeamMemberRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		respondError(w, http.StatusBadRequest, "invalid request body", "invalid_input")
		return
	}

	// Validate email
	if req.Email == "" || !isValidEmail(req.Email) {
		respondError(w, http.StatusBadRequest, "valid email is required", "invalid_input")
		return
	}

	// Get user's team ID
	teamID, err := s.getUserTeamID(ctx, userID)
	if err != nil {
		respondError(w, http.StatusNotFound, "no active team found", "not_found")
		return
	}

	// Check if user is owner or admin
	role, err := s.getUserTeamRole(ctx, userID, teamID)
	if err != nil || (role != "owner" && role != "admin") {
		respondError(w, http.StatusForbidden, "only team owners and admins can invite members", "forbidden")
		return
	}

	// Check if invitee is already a member
	existingMember, err := s.db.Client.TeamMember.Query().
		Where(
			teammember.TeamID(teamID),
			teammember.HasUserWith(user.Email(req.Email)),
		).
		First(ctx)
	if err == nil && existingMember != nil {
		respondError(w, http.StatusConflict, "user is already a team member", "already_member")
		return
	} else if err != nil && !ent.IsNotFound(err) {
		s.logger.Error("Failed to check existing member", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to check membership", "internal_error")
		return
	}

	// Check if there's already a pending invitation
	existingInv, err := s.db.Client.TeamInvitation.Query().
		Where(
			teaminvitation.TeamID(teamID),
			teaminvitation.InviteeEmail(req.Email),
			teaminvitation.Status("pending"),
		).
		First(ctx)
	if err == nil && existingInv != nil {
		respondError(w, http.StatusConflict, "pending invitation already exists", "invitation_exists")
		return
	} else if err != nil && !ent.IsNotFound(err) {
		s.logger.Error("Failed to check existing invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to check invitation", "internal_error")
		return
	}

	// Get invitee user ID if they exist
	var inviteeID *int64
	inviteeUser, err := s.db.Client.User.Query().
		Where(user.Email(req.Email)).
		Only(ctx)
	if err == nil {
		inviteeID = &inviteeUser.ID
	} else if err != nil && !ent.IsNotFound(err) {
		s.logger.Error("Failed to get invitee user", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to get user", "internal_error")
		return
	}

	// Generate acceptance token for one-click email acceptance
	acceptanceToken, tokenErr := generateInviteCode()
	if tokenErr != nil {
		s.logger.Error("Failed to generate acceptance token", zap.Error(tokenErr))
		respondError(w, http.StatusInternalServerError, "failed to create invitation", "internal_error")
		return
	}

	// Create invitation with acceptance token (expires in 7 days)
	tokenExpires := time.Now().Add(7 * 24 * time.Hour)
	newInv, err := s.db.Client.TeamInvitation.Create().
		SetTeamID(teamID).
		SetInviterID(userID).
		SetInviteeEmail(req.Email).
		SetNillableInviteeID(inviteeID).
		SetStatus("pending").
		SetAcceptanceToken(acceptanceToken).
		SetTokenExpiresAt(tokenExpires).
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to create invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to create invitation", "internal_error")
		return
	}

	invitationID := newInv.ID

	// Fetch created invitation with edges
	invitation, err := s.getInvitation(ctx, invitationID)
	if err != nil {
		s.logger.Error("Failed to fetch created invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitation", "internal_error")
		return
	}

	s.logger.Info("Team invitation created",
		zap.Int64("invitation_id", invitationID),
		zap.Int64("team_id", teamID),
		zap.String("invitee_email", req.Email),
	)

	// Send email notification if email service is available
	if emailSvc := s.GetEmailService(); emailSvc != nil {
		// Get inviter name
		inviter, err := s.db.Client.User.Get(ctx, userID)
		inviterName := ""
		if err == nil {
			if inviter.Name != nil {
				inviterName = *inviter.Name
			} else {
				inviterName = inviter.Email
			}
		}

		// Get team name
		teamEntity, err := s.db.Client.Team.Get(ctx, teamID)
		teamName := ""
		if err == nil {
			teamName = teamEntity.Name
		}

		appURL := s.getAppURL()

		if inviteeID != nil {
			// Existing user — send project invitation with accept link
			if err := emailSvc.SendProjectInvitation(ctx, req.Email, inviterName, teamName, acceptanceToken, appURL); err != nil {
				s.logger.Warn("Failed to send team invitation email",
					zap.String("to", req.Email),
					zap.Error(err),
				)
			}
		} else {
			// New user — auto-generate invite code and send signup link with accept token
			inviteCode, codeErr := generateTeamInviteCode()
			if codeErr == nil {
				// Create a platform invite for this user
				expireTime := time.Now().Add(7 * 24 * time.Hour)
				_, err := s.db.Client.Invite.Create().
					SetCode(inviteCode).
					SetInviterID(userID).
					SetExpiresAt(expireTime).
					Save(ctx)
				if err == nil {
					// Store invite code on the team invitation for retrieval during acceptance
					_, _ = s.db.Client.TeamInvitation.UpdateOneID(invitationID).
						SetInviteCode(inviteCode).
						Save(ctx)

					if err := emailSvc.SendProjectInvitationNewUser(ctx, req.Email, inviterName, teamName, acceptanceToken, appURL); err != nil {
						s.logger.Warn("Failed to send team invitation email to new user",
							zap.String("to", req.Email),
							zap.Error(err),
						)
					}
				}
			}
		}
	}

	respondJSON(w, http.StatusCreated, invitation)
}

// HandleGetMyInvitations returns all pending invitations for the current user
func (s *Server) HandleGetMyInvitations(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)
	email := r.Context().Value(UserEmailKey).(string)

	// Get pending invitations for this user
	entInvitations, err := s.db.Client.TeamInvitation.Query().
		Where(
			teaminvitation.Or(
				teaminvitation.InviteeID(userID),
				teaminvitation.InviteeEmail(email),
			),
			teaminvitation.Status("pending"),
		).
		WithTeam().
		WithInviter().
		Order(ent.Desc(teaminvitation.FieldCreatedAt)).
		All(ctx)
	if err != nil {
		s.logger.Error("Failed to get invitations", zap.Error(err), zap.Int64("user_id", userID))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitations", "internal_error")
		return
	}

	invitations := make([]TeamInvitation, 0, len(entInvitations))
	for _, entInv := range entInvitations {
		inv := TeamInvitation{
			ID:           entInv.ID,
			TeamID:       entInv.TeamID,
			InviterID:    entInv.InviterID,
			InviteeEmail: entInv.InviteeEmail,
			InviteeID:    entInv.InviteeID,
			Status:       entInv.Status,
			CreatedAt:    entInv.CreatedAt,
			RespondedAt:  entInv.RespondedAt,
		}

		if entInv.Edges.Team != nil {
			inv.TeamName = entInv.Edges.Team.Name
		}
		if entInv.Edges.Inviter != nil {
			inv.InviterName = entInv.Edges.Inviter.Name
		}

		invitations = append(invitations, inv)
	}

	respondJSON(w, http.StatusOK, invitations)
}

// HandleAcceptInvitation accepts a team invitation
func (s *Server) HandleAcceptInvitation(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)
	email := r.Context().Value(UserEmailKey).(string)

	invitationID, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		respondError(w, http.StatusBadRequest, "invalid invitation ID", "invalid_input")
		return
	}

	// Get invitation and verify it's for this user
	entInv, err := s.db.Client.TeamInvitation.Get(ctx, invitationID)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "invitation not found", "not_found")
			return
		}
		s.logger.Error("Failed to get invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitation", "internal_error")
		return
	}

	// Verify invitation is for this user
	if entInv.InviteeEmail != email && (entInv.InviteeID == nil || *entInv.InviteeID != userID) {
		respondError(w, http.StatusForbidden, "invitation is not for you", "forbidden")
		return
	}

	// Check if invitation is still pending
	if entInv.Status != "pending" {
		respondError(w, http.StatusConflict, "invitation already responded to", "already_responded")
		return
	}

	// Begin Ent transaction
	tx, err := s.db.Client.Tx(ctx)
	if err != nil {
		s.logger.Error("Failed to begin transaction", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to process invitation", "internal_error")
		return
	}
	defer tx.Rollback()

	// Update invitation status
	now := time.Now()
	_, err = tx.TeamInvitation.UpdateOneID(invitationID).
		SetStatus("accepted").
		SetInviteeID(userID).
		SetRespondedAt(now).
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to update invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to update invitation", "internal_error")
		return
	}

	// Add user to team
	_, err = tx.TeamMember.Create().
		SetTeamID(entInv.TeamID).
		SetUserID(userID).
		SetRole("member").
		SetStatus("active").
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to add team member", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to add team member", "internal_error")
		return
	}

	// Add user to all existing team projects
	// Get all projects for this team
	projects, err := tx.Project.Query().
		Where(project.TeamID(entInv.TeamID)).
		All(ctx)
	if err != nil {
		s.logger.Error("Failed to get team projects", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to get team projects", "internal_error")
		return
	}

	// Add user as member to each project
	for _, proj := range projects {
		_, err := tx.ProjectMember.Create().
			SetProjectID(proj.ID).
			SetUserID(userID).
			SetRole("member").
			SetGrantedBy(proj.OwnerID).
			Save(ctx)
		if err != nil {
			s.logger.Error("Failed to add user to project", zap.Error(err), zap.Int64("project_id", proj.ID))
			respondError(w, http.StatusInternalServerError, "failed to add to team projects", "internal_error")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		s.logger.Error("Failed to commit transaction", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to process invitation", "internal_error")
		return
	}

	s.logger.Info("Invitation accepted",
		zap.Int64("invitation_id", invitationID),
		zap.Int64("user_id", userID),
		zap.Int64("team_id", entInv.TeamID),
	)

	respondJSON(w, http.StatusOK, map[string]string{"message": "invitation accepted"})
}

// HandleRejectInvitation rejects a team invitation
func (s *Server) HandleRejectInvitation(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)
	email := r.Context().Value(UserEmailKey).(string)

	invitationID, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
	if err != nil {
		respondError(w, http.StatusBadRequest, "invalid invitation ID", "invalid_input")
		return
	}

	// Get invitation and verify it's for this user
	entInv, err := s.db.Client.TeamInvitation.Get(ctx, invitationID)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "invitation not found", "not_found")
			return
		}
		s.logger.Error("Failed to get invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitation", "internal_error")
		return
	}

	// Verify invitation is for this user
	if entInv.InviteeEmail != email && (entInv.InviteeID == nil || *entInv.InviteeID != userID) {
		respondError(w, http.StatusForbidden, "invitation is not for you", "forbidden")
		return
	}

	// Check if invitation is still pending
	if entInv.Status != "pending" {
		respondError(w, http.StatusConflict, "invitation already responded to", "already_responded")
		return
	}

	// Update invitation status
	now := time.Now()
	_, err = s.db.Client.TeamInvitation.UpdateOneID(invitationID).
		SetStatus("rejected").
		SetInviteeID(userID).
		SetRespondedAt(now).
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to reject invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to reject invitation", "internal_error")
		return
	}

	s.logger.Info("Invitation rejected",
		zap.Int64("invitation_id", invitationID),
		zap.Int64("user_id", userID),
	)

	respondJSON(w, http.StatusOK, map[string]string{"message": "invitation rejected"})
}

// HandleRemoveTeamMember removes a member from the team
func (s *Server) HandleRemoveTeamMember(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)

	memberID, err := strconv.ParseInt(chi.URLParam(r, "memberId"), 10, 64)
	if err != nil {
		respondError(w, http.StatusBadRequest, "invalid member ID", "invalid_input")
		return
	}

	// Get user's team ID
	teamID, err := s.getUserTeamID(ctx, userID)
	if err != nil {
		respondError(w, http.StatusNotFound, "no active team found", "not_found")
		return
	}

	// Check if user is owner or admin
	role, err := s.getUserTeamRole(ctx, userID, teamID)
	if err != nil || (role != "owner" && role != "admin") {
		respondError(w, http.StatusForbidden, "only team owners and admins can remove members", "forbidden")
		return
	}

	// Get member to remove
	member, err := s.db.Client.TeamMember.Query().
		Where(
			teammember.ID(memberID),
			teammember.TeamID(teamID),
		).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "member not found", "not_found")
			return
		}
		s.logger.Error("Failed to get member", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to get member", "internal_error")
		return
	}

	// Cannot remove team owner
	if member.Role == "owner" {
		respondError(w, http.StatusForbidden, "cannot remove team owner", "forbidden")
		return
	}

	memberUserID := member.UserID

	// Delete team member
	err = s.db.Client.TeamMember.DeleteOneID(memberID).Exec(ctx)
	if err != nil {
		s.logger.Error("Failed to remove team member", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to remove member", "internal_error")
		return
	}

	s.logger.Info("Team member removed",
		zap.Int64("member_id", memberID),
		zap.Int64("user_id", memberUserID),
		zap.Int64("team_id", teamID),
	)

	respondJSON(w, http.StatusOK, map[string]string{"message": "member removed"})
}

// Helper functions

func (s *Server) getUserTeamID(ctx context.Context, userID int64) (int64, error) {
	tm, err := s.db.Client.TeamMember.Query().
		Where(
			teammember.UserID(userID),
			teammember.Status("active"),
		).
		First(ctx)
	if err != nil {
		return 0, err
	}
	return tm.TeamID, nil
}

func (s *Server) getUserTeamRole(ctx context.Context, userID, teamID int64) (string, error) {
	tm, err := s.db.Client.TeamMember.Query().
		Where(
			teammember.UserID(userID),
			teammember.TeamID(teamID),
			teammember.Status("active"),
		).
		Only(ctx)
	if err != nil {
		return "", err
	}
	return tm.Role, nil
}

func (s *Server) getInvitation(ctx context.Context, invitationID int64) (*TeamInvitation, error) {
	entInv, err := s.db.Client.TeamInvitation.Query().
		Where(teaminvitation.ID(invitationID)).
		WithTeam().
		WithInviter().
		Only(ctx)
	if err != nil {
		return nil, err
	}

	inv := TeamInvitation{
		ID:           entInv.ID,
		TeamID:       entInv.TeamID,
		InviterID:    entInv.InviterID,
		InviteeEmail: entInv.InviteeEmail,
		InviteeID:    entInv.InviteeID,
		Status:       entInv.Status,
		CreatedAt:    entInv.CreatedAt,
		RespondedAt:  entInv.RespondedAt,
	}

	if entInv.Edges.Team != nil {
		inv.TeamName = entInv.Edges.Team.Name
	}
	if entInv.Edges.Inviter != nil {
		inv.InviterName = entInv.Edges.Inviter.Name
	}

	return &inv, nil
}

// generateTeamInviteCode creates a random invite code (delegates to the shared generator)
func generateTeamInviteCode() (string, error) {
	return generateInviteCode()
}

// TokenInvitationResponse is returned by the token lookup endpoint
type TokenInvitationResponse struct {
	InvitationID int64  `json:"invitation_id"`
	TeamName     string `json:"team_name"`
	InviterName  string `json:"inviter_name"`
	InviteeEmail string `json:"invitee_email"`
	Status       string `json:"status"`
	RequiresSignup bool `json:"requires_signup"`
	InviteCode   string `json:"invite_code,omitempty"`
}

// HandleGetInvitationByToken returns invitation info for a given acceptance token (public, no auth required)
func (s *Server) HandleGetInvitationByToken(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	token := r.URL.Query().Get("token")
	if token == "" {
		respondError(w, http.StatusBadRequest, "token is required", "invalid_input")
		return
	}

	// Get invitation by token with team and inviter edges
	entInv, err := s.db.Client.TeamInvitation.Query().
		Where(teaminvitation.AcceptanceToken(token)).
		WithTeam().
		WithInviter().
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "invitation not found or token is invalid", "not_found")
			return
		}
		s.logger.Error("Failed to get invitation by token", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitation", "internal_error")
		return
	}

	// Check token expiry
	if entInv.TokenExpiresAt != nil && time.Now().After(*entInv.TokenExpiresAt) {
		respondError(w, http.StatusGone, "invitation link has expired", "token_expired")
		return
	}

	// Check if invitation is still pending
	if entInv.Status != "pending" {
		respondError(w, http.StatusConflict, "invitation has already been "+entInv.Status, "already_responded")
		return
	}

	// Build response
	resp := TokenInvitationResponse{
		InvitationID: entInv.ID,
		InviteeEmail: entInv.InviteeEmail,
		Status:       entInv.Status,
		RequiresSignup: entInv.InviteeID == nil,
	}

	if entInv.Edges.Team != nil {
		resp.TeamName = entInv.Edges.Team.Name
	}

	if entInv.Edges.Inviter != nil {
		inviterName := ""
		if entInv.Edges.Inviter.Name != nil {
			inviterName = *entInv.Edges.Inviter.Name
		} else {
			inviterName = entInv.Edges.Inviter.Email
		}
		resp.InviterName = inviterName
	}

	if resp.RequiresSignup && entInv.InviteCode != nil {
		resp.InviteCode = *entInv.InviteCode
	}

	respondJSON(w, http.StatusOK, resp)
}

// HandleAcceptInvitationByToken accepts a team invitation using the acceptance token (requires auth)
func (s *Server) HandleAcceptInvitationByToken(w http.ResponseWriter, r *http.Request) {
	ctx, cancel := context.WithTimeout(r.Context(), 5*time.Second)
	defer cancel()

	userID := r.Context().Value(UserIDKey).(int64)
	email := r.Context().Value(UserEmailKey).(string)

	var req struct {
		Token string `json:"token"`
	}
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil || req.Token == "" {
		respondError(w, http.StatusBadRequest, "token is required", "invalid_input")
		return
	}

	// Find invitation by token
	entInv, err := s.db.Client.TeamInvitation.Query().
		Where(teaminvitation.AcceptanceToken(req.Token)).
		Only(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			respondError(w, http.StatusNotFound, "invitation not found or token is invalid", "not_found")
			return
		}
		s.logger.Error("Failed to get invitation by token", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to fetch invitation", "internal_error")
		return
	}

	// Check token expiry
	if entInv.TokenExpiresAt != nil && time.Now().After(*entInv.TokenExpiresAt) {
		respondError(w, http.StatusGone, "invitation link has expired", "token_expired")
		return
	}

	// Verify invitation is for this user
	if entInv.InviteeEmail != email {
		respondError(w, http.StatusForbidden, "this invitation is for a different email address", "forbidden")
		return
	}

	// Check if invitation is still pending
	if entInv.Status != "pending" {
		respondError(w, http.StatusConflict, "invitation has already been "+entInv.Status, "already_responded")
		return
	}

	// Begin Ent transaction
	tx, err := s.db.Client.Tx(ctx)
	if err != nil {
		s.logger.Error("Failed to begin transaction", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to process invitation", "internal_error")
		return
	}
	defer tx.Rollback()

	// Update invitation status
	now := time.Now()
	_, err = tx.TeamInvitation.UpdateOneID(entInv.ID).
		SetStatus("accepted").
		SetInviteeID(userID).
		SetRespondedAt(now).
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to update invitation", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to update invitation", "internal_error")
		return
	}

	// Add user to team
	_, err = tx.TeamMember.Create().
		SetTeamID(entInv.TeamID).
		SetUserID(userID).
		SetRole("member").
		SetStatus("active").
		Save(ctx)
	if err != nil {
		s.logger.Error("Failed to add team member", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to add team member", "internal_error")
		return
	}

	// Add user to all existing team projects
	projects, err := tx.Project.Query().
		Where(project.TeamID(entInv.TeamID)).
		All(ctx)
	if err != nil {
		s.logger.Error("Failed to get team projects", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to get team projects", "internal_error")
		return
	}

	for _, proj := range projects {
		_, err := tx.ProjectMember.Create().
			SetProjectID(proj.ID).
			SetUserID(userID).
			SetRole("member").
			SetGrantedBy(proj.OwnerID).
			Save(ctx)
		if err != nil {
			s.logger.Error("Failed to add user to project", zap.Error(err), zap.Int64("project_id", proj.ID))
			respondError(w, http.StatusInternalServerError, "failed to add to team projects", "internal_error")
			return
		}
	}

	if err := tx.Commit(); err != nil {
		s.logger.Error("Failed to commit transaction", zap.Error(err))
		respondError(w, http.StatusInternalServerError, "failed to process invitation", "internal_error")
		return
	}

	s.logger.Info("Invitation accepted via token",
		zap.Int64("invitation_id", entInv.ID),
		zap.Int64("user_id", userID),
		zap.Int64("team_id", entInv.TeamID),
	)

	respondJSON(w, http.StatusOK, map[string]string{"message": "invitation accepted"})
}

func isValidEmail(email string) bool {
	// Basic email validation
	if len(email) < 3 || len(email) > 254 {
		return false
	}

	atIndex := -1
	for i, c := range email {
		if c == '@' {
			if atIndex >= 0 {
				return false // Multiple @ symbols
			}
			atIndex = i
		}
	}

	if atIndex <= 0 || atIndex >= len(email)-1 {
		return false
	}

	return true
}
