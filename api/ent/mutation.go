// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"taskai/ent/apikey"
	"taskai/ent/cloudinarycredential"
	"taskai/ent/emailprovider"
	"taskai/ent/invite"
	"taskai/ent/pageversion"
	"taskai/ent/predicate"
	"taskai/ent/project"
	"taskai/ent/projectmember"
	"taskai/ent/sprint"
	"taskai/ent/swimlane"
	"taskai/ent/tag"
	"taskai/ent/task"
	"taskai/ent/taskattachment"
	"taskai/ent/taskcomment"
	"taskai/ent/tasktag"
	"taskai/ent/team"
	"taskai/ent/teaminvitation"
	"taskai/ent/teammember"
	"taskai/ent/user"
	"taskai/ent/useractivity"
	"taskai/ent/wikiblock"
	"taskai/ent/wikipage"
	"taskai/ent/yjsupdate"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey               = "APIKey"
	TypeCloudinaryCredential = "CloudinaryCredential"
	TypeEmailProvider        = "EmailProvider"
	TypeInvite               = "Invite"
	TypePageVersion          = "PageVersion"
	TypeProject              = "Project"
	TypeProjectMember        = "ProjectMember"
	TypeSprint               = "Sprint"
	TypeSwimLane             = "SwimLane"
	TypeTag                  = "Tag"
	TypeTask                 = "Task"
	TypeTaskAttachment       = "TaskAttachment"
	TypeTaskComment          = "TaskComment"
	TypeTaskTag              = "TaskTag"
	TypeTeam                 = "Team"
	TypeTeamInvitation       = "TeamInvitation"
	TypeTeamMember           = "TeamMember"
	TypeUser                 = "User"
	TypeUserActivity         = "UserActivity"
	TypeWikiBlock            = "WikiBlock"
	TypeWikiPage             = "WikiPage"
	TypeYjsUpdate            = "YjsUpdate"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	key_hash      *string
	key_prefix    *string
	last_used_at  *time.Time
	created_at    *time.Time
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*APIKey, error)
	predicates    []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int64) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIKey entities.
func (m *APIKeyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetKeyHash sets the "key_hash" field.
func (m *APIKeyMutation) SetKeyHash(s string) {
	m.key_hash = &s
}

// KeyHash returns the value of the "key_hash" field in the mutation.
func (m *APIKeyMutation) KeyHash() (r string, exists bool) {
	v := m.key_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyHash returns the old "key_hash" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyHash: %w", err)
	}
	return oldValue.KeyHash, nil
}

// ResetKeyHash resets all changes to the "key_hash" field.
func (m *APIKeyMutation) ResetKeyHash() {
	m.key_hash = nil
}

// SetKeyPrefix sets the "key_prefix" field.
func (m *APIKeyMutation) SetKeyPrefix(s string) {
	m.key_prefix = &s
}

// KeyPrefix returns the value of the "key_prefix" field in the mutation.
func (m *APIKeyMutation) KeyPrefix() (r string, exists bool) {
	v := m.key_prefix
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyPrefix returns the old "key_prefix" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKeyPrefix(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeyPrefix is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeyPrefix requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyPrefix: %w", err)
	}
	return oldValue.KeyPrefix, nil
}

// ResetKeyPrefix resets all changes to the "key_prefix" field.
func (m *APIKeyMutation) ResetKeyPrefix() {
	m.key_prefix = nil
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *APIKeyMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *APIKeyMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *APIKeyMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[apikey.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *APIKeyMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *APIKeyMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, apikey.FieldLastUsedAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.key_hash != nil {
		fields = append(fields, apikey.FieldKeyHash)
	}
	if m.key_prefix != nil {
		fields = append(fields, apikey.FieldKeyPrefix)
	}
	if m.last_used_at != nil {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldKeyHash:
		return m.KeyHash()
	case apikey.FieldKeyPrefix:
		return m.KeyPrefix()
	case apikey.FieldLastUsedAt:
		return m.LastUsedAt()
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldKeyHash:
		return m.OldKeyHash(ctx)
	case apikey.FieldKeyPrefix:
		return m.OldKeyPrefix(ctx)
	case apikey.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldKeyHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyHash(v)
		return nil
	case apikey.FieldKeyPrefix:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyPrefix(v)
		return nil
	case apikey.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldLastUsedAt) {
		fields = append(fields, apikey.FieldLastUsedAt)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldKeyHash:
		m.ResetKeyHash()
		return nil
	case apikey.FieldKeyPrefix:
		m.ResetKeyPrefix()
		return nil
	case apikey.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// CloudinaryCredentialMutation represents an operation that mutates the CloudinaryCredential nodes in the graph.
type CloudinaryCredentialMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	cloud_name              *string
	api_key                 *string
	api_secret              *string
	max_file_size_mb        *int
	addmax_file_size_mb     *int
	status                  *string
	last_checked_at         *time.Time
	last_error              *string
	consecutive_failures    *int
	addconsecutive_failures *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	user                    *int64
	cleareduser             bool
	done                    bool
	oldValue                func(context.Context) (*CloudinaryCredential, error)
	predicates              []predicate.CloudinaryCredential
}

var _ ent.Mutation = (*CloudinaryCredentialMutation)(nil)

// cloudinarycredentialOption allows management of the mutation configuration using functional options.
type cloudinarycredentialOption func(*CloudinaryCredentialMutation)

// newCloudinaryCredentialMutation creates new mutation for the CloudinaryCredential entity.
func newCloudinaryCredentialMutation(c config, op Op, opts ...cloudinarycredentialOption) *CloudinaryCredentialMutation {
	m := &CloudinaryCredentialMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudinaryCredential,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudinaryCredentialID sets the ID field of the mutation.
func withCloudinaryCredentialID(id int64) cloudinarycredentialOption {
	return func(m *CloudinaryCredentialMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudinaryCredential
		)
		m.oldValue = func(ctx context.Context) (*CloudinaryCredential, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudinaryCredential.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudinaryCredential sets the old CloudinaryCredential of the mutation.
func withCloudinaryCredential(node *CloudinaryCredential) cloudinarycredentialOption {
	return func(m *CloudinaryCredentialMutation) {
		m.oldValue = func(context.Context) (*CloudinaryCredential, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudinaryCredentialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudinaryCredentialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudinaryCredential entities.
func (m *CloudinaryCredentialMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudinaryCredentialMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudinaryCredentialMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudinaryCredential.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CloudinaryCredentialMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CloudinaryCredentialMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CloudinaryCredentialMutation) ResetUserID() {
	m.user = nil
}

// SetCloudName sets the "cloud_name" field.
func (m *CloudinaryCredentialMutation) SetCloudName(s string) {
	m.cloud_name = &s
}

// CloudName returns the value of the "cloud_name" field in the mutation.
func (m *CloudinaryCredentialMutation) CloudName() (r string, exists bool) {
	v := m.cloud_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudName returns the old "cloud_name" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldCloudName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudName: %w", err)
	}
	return oldValue.CloudName, nil
}

// ResetCloudName resets all changes to the "cloud_name" field.
func (m *CloudinaryCredentialMutation) ResetCloudName() {
	m.cloud_name = nil
}

// SetAPIKey sets the "api_key" field.
func (m *CloudinaryCredentialMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CloudinaryCredentialMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CloudinaryCredentialMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetAPISecret sets the "api_secret" field.
func (m *CloudinaryCredentialMutation) SetAPISecret(s string) {
	m.api_secret = &s
}

// APISecret returns the value of the "api_secret" field in the mutation.
func (m *CloudinaryCredentialMutation) APISecret() (r string, exists bool) {
	v := m.api_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldAPISecret returns the old "api_secret" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldAPISecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPISecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPISecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPISecret: %w", err)
	}
	return oldValue.APISecret, nil
}

// ResetAPISecret resets all changes to the "api_secret" field.
func (m *CloudinaryCredentialMutation) ResetAPISecret() {
	m.api_secret = nil
}

// SetMaxFileSizeMB sets the "max_file_size_mb" field.
func (m *CloudinaryCredentialMutation) SetMaxFileSizeMB(i int) {
	m.max_file_size_mb = &i
	m.addmax_file_size_mb = nil
}

// MaxFileSizeMB returns the value of the "max_file_size_mb" field in the mutation.
func (m *CloudinaryCredentialMutation) MaxFileSizeMB() (r int, exists bool) {
	v := m.max_file_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxFileSizeMB returns the old "max_file_size_mb" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldMaxFileSizeMB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxFileSizeMB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxFileSizeMB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxFileSizeMB: %w", err)
	}
	return oldValue.MaxFileSizeMB, nil
}

// AddMaxFileSizeMB adds i to the "max_file_size_mb" field.
func (m *CloudinaryCredentialMutation) AddMaxFileSizeMB(i int) {
	if m.addmax_file_size_mb != nil {
		*m.addmax_file_size_mb += i
	} else {
		m.addmax_file_size_mb = &i
	}
}

// AddedMaxFileSizeMB returns the value that was added to the "max_file_size_mb" field in this mutation.
func (m *CloudinaryCredentialMutation) AddedMaxFileSizeMB() (r int, exists bool) {
	v := m.addmax_file_size_mb
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxFileSizeMB resets all changes to the "max_file_size_mb" field.
func (m *CloudinaryCredentialMutation) ResetMaxFileSizeMB() {
	m.max_file_size_mb = nil
	m.addmax_file_size_mb = nil
}

// SetStatus sets the "status" field.
func (m *CloudinaryCredentialMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CloudinaryCredentialMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CloudinaryCredentialMutation) ResetStatus() {
	m.status = nil
}

// SetLastCheckedAt sets the "last_checked_at" field.
func (m *CloudinaryCredentialMutation) SetLastCheckedAt(t time.Time) {
	m.last_checked_at = &t
}

// LastCheckedAt returns the value of the "last_checked_at" field in the mutation.
func (m *CloudinaryCredentialMutation) LastCheckedAt() (r time.Time, exists bool) {
	v := m.last_checked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCheckedAt returns the old "last_checked_at" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldLastCheckedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCheckedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCheckedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCheckedAt: %w", err)
	}
	return oldValue.LastCheckedAt, nil
}

// ClearLastCheckedAt clears the value of the "last_checked_at" field.
func (m *CloudinaryCredentialMutation) ClearLastCheckedAt() {
	m.last_checked_at = nil
	m.clearedFields[cloudinarycredential.FieldLastCheckedAt] = struct{}{}
}

// LastCheckedAtCleared returns if the "last_checked_at" field was cleared in this mutation.
func (m *CloudinaryCredentialMutation) LastCheckedAtCleared() bool {
	_, ok := m.clearedFields[cloudinarycredential.FieldLastCheckedAt]
	return ok
}

// ResetLastCheckedAt resets all changes to the "last_checked_at" field.
func (m *CloudinaryCredentialMutation) ResetLastCheckedAt() {
	m.last_checked_at = nil
	delete(m.clearedFields, cloudinarycredential.FieldLastCheckedAt)
}

// SetLastError sets the "last_error" field.
func (m *CloudinaryCredentialMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *CloudinaryCredentialMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ResetLastError resets all changes to the "last_error" field.
func (m *CloudinaryCredentialMutation) ResetLastError() {
	m.last_error = nil
}

// SetConsecutiveFailures sets the "consecutive_failures" field.
func (m *CloudinaryCredentialMutation) SetConsecutiveFailures(i int) {
	m.consecutive_failures = &i
	m.addconsecutive_failures = nil
}

// ConsecutiveFailures returns the value of the "consecutive_failures" field in the mutation.
func (m *CloudinaryCredentialMutation) ConsecutiveFailures() (r int, exists bool) {
	v := m.consecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// OldConsecutiveFailures returns the old "consecutive_failures" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldConsecutiveFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsecutiveFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsecutiveFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsecutiveFailures: %w", err)
	}
	return oldValue.ConsecutiveFailures, nil
}

// AddConsecutiveFailures adds i to the "consecutive_failures" field.
func (m *CloudinaryCredentialMutation) AddConsecutiveFailures(i int) {
	if m.addconsecutive_failures != nil {
		*m.addconsecutive_failures += i
	} else {
		m.addconsecutive_failures = &i
	}
}

// AddedConsecutiveFailures returns the value that was added to the "consecutive_failures" field in this mutation.
func (m *CloudinaryCredentialMutation) AddedConsecutiveFailures() (r int, exists bool) {
	v := m.addconsecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// ResetConsecutiveFailures resets all changes to the "consecutive_failures" field.
func (m *CloudinaryCredentialMutation) ResetConsecutiveFailures() {
	m.consecutive_failures = nil
	m.addconsecutive_failures = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CloudinaryCredentialMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CloudinaryCredentialMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CloudinaryCredentialMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CloudinaryCredentialMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CloudinaryCredentialMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CloudinaryCredential entity.
// If the CloudinaryCredential object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudinaryCredentialMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CloudinaryCredentialMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CloudinaryCredentialMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[cloudinarycredential.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CloudinaryCredentialMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CloudinaryCredentialMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CloudinaryCredentialMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CloudinaryCredentialMutation builder.
func (m *CloudinaryCredentialMutation) Where(ps ...predicate.CloudinaryCredential) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudinaryCredentialMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudinaryCredentialMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudinaryCredential, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudinaryCredentialMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudinaryCredentialMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudinaryCredential).
func (m *CloudinaryCredentialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudinaryCredentialMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.user != nil {
		fields = append(fields, cloudinarycredential.FieldUserID)
	}
	if m.cloud_name != nil {
		fields = append(fields, cloudinarycredential.FieldCloudName)
	}
	if m.api_key != nil {
		fields = append(fields, cloudinarycredential.FieldAPIKey)
	}
	if m.api_secret != nil {
		fields = append(fields, cloudinarycredential.FieldAPISecret)
	}
	if m.max_file_size_mb != nil {
		fields = append(fields, cloudinarycredential.FieldMaxFileSizeMB)
	}
	if m.status != nil {
		fields = append(fields, cloudinarycredential.FieldStatus)
	}
	if m.last_checked_at != nil {
		fields = append(fields, cloudinarycredential.FieldLastCheckedAt)
	}
	if m.last_error != nil {
		fields = append(fields, cloudinarycredential.FieldLastError)
	}
	if m.consecutive_failures != nil {
		fields = append(fields, cloudinarycredential.FieldConsecutiveFailures)
	}
	if m.created_at != nil {
		fields = append(fields, cloudinarycredential.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cloudinarycredential.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudinaryCredentialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudinarycredential.FieldUserID:
		return m.UserID()
	case cloudinarycredential.FieldCloudName:
		return m.CloudName()
	case cloudinarycredential.FieldAPIKey:
		return m.APIKey()
	case cloudinarycredential.FieldAPISecret:
		return m.APISecret()
	case cloudinarycredential.FieldMaxFileSizeMB:
		return m.MaxFileSizeMB()
	case cloudinarycredential.FieldStatus:
		return m.Status()
	case cloudinarycredential.FieldLastCheckedAt:
		return m.LastCheckedAt()
	case cloudinarycredential.FieldLastError:
		return m.LastError()
	case cloudinarycredential.FieldConsecutiveFailures:
		return m.ConsecutiveFailures()
	case cloudinarycredential.FieldCreatedAt:
		return m.CreatedAt()
	case cloudinarycredential.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudinaryCredentialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudinarycredential.FieldUserID:
		return m.OldUserID(ctx)
	case cloudinarycredential.FieldCloudName:
		return m.OldCloudName(ctx)
	case cloudinarycredential.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case cloudinarycredential.FieldAPISecret:
		return m.OldAPISecret(ctx)
	case cloudinarycredential.FieldMaxFileSizeMB:
		return m.OldMaxFileSizeMB(ctx)
	case cloudinarycredential.FieldStatus:
		return m.OldStatus(ctx)
	case cloudinarycredential.FieldLastCheckedAt:
		return m.OldLastCheckedAt(ctx)
	case cloudinarycredential.FieldLastError:
		return m.OldLastError(ctx)
	case cloudinarycredential.FieldConsecutiveFailures:
		return m.OldConsecutiveFailures(ctx)
	case cloudinarycredential.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cloudinarycredential.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown CloudinaryCredential field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudinaryCredentialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudinarycredential.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case cloudinarycredential.FieldCloudName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudName(v)
		return nil
	case cloudinarycredential.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case cloudinarycredential.FieldAPISecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPISecret(v)
		return nil
	case cloudinarycredential.FieldMaxFileSizeMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxFileSizeMB(v)
		return nil
	case cloudinarycredential.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cloudinarycredential.FieldLastCheckedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCheckedAt(v)
		return nil
	case cloudinarycredential.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case cloudinarycredential.FieldConsecutiveFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsecutiveFailures(v)
		return nil
	case cloudinarycredential.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cloudinarycredential.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudinaryCredentialMutation) AddedFields() []string {
	var fields []string
	if m.addmax_file_size_mb != nil {
		fields = append(fields, cloudinarycredential.FieldMaxFileSizeMB)
	}
	if m.addconsecutive_failures != nil {
		fields = append(fields, cloudinarycredential.FieldConsecutiveFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudinaryCredentialMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cloudinarycredential.FieldMaxFileSizeMB:
		return m.AddedMaxFileSizeMB()
	case cloudinarycredential.FieldConsecutiveFailures:
		return m.AddedConsecutiveFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudinaryCredentialMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cloudinarycredential.FieldMaxFileSizeMB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxFileSizeMB(v)
		return nil
	case cloudinarycredential.FieldConsecutiveFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsecutiveFailures(v)
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudinaryCredentialMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cloudinarycredential.FieldLastCheckedAt) {
		fields = append(fields, cloudinarycredential.FieldLastCheckedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudinaryCredentialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudinaryCredentialMutation) ClearField(name string) error {
	switch name {
	case cloudinarycredential.FieldLastCheckedAt:
		m.ClearLastCheckedAt()
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudinaryCredentialMutation) ResetField(name string) error {
	switch name {
	case cloudinarycredential.FieldUserID:
		m.ResetUserID()
		return nil
	case cloudinarycredential.FieldCloudName:
		m.ResetCloudName()
		return nil
	case cloudinarycredential.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case cloudinarycredential.FieldAPISecret:
		m.ResetAPISecret()
		return nil
	case cloudinarycredential.FieldMaxFileSizeMB:
		m.ResetMaxFileSizeMB()
		return nil
	case cloudinarycredential.FieldStatus:
		m.ResetStatus()
		return nil
	case cloudinarycredential.FieldLastCheckedAt:
		m.ResetLastCheckedAt()
		return nil
	case cloudinarycredential.FieldLastError:
		m.ResetLastError()
		return nil
	case cloudinarycredential.FieldConsecutiveFailures:
		m.ResetConsecutiveFailures()
		return nil
	case cloudinarycredential.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cloudinarycredential.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudinaryCredentialMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, cloudinarycredential.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudinaryCredentialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudinarycredential.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudinaryCredentialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudinaryCredentialMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudinaryCredentialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, cloudinarycredential.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudinaryCredentialMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudinarycredential.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudinaryCredentialMutation) ClearEdge(name string) error {
	switch name {
	case cloudinarycredential.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudinaryCredentialMutation) ResetEdge(name string) error {
	switch name {
	case cloudinarycredential.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown CloudinaryCredential edge %s", name)
}

// EmailProviderMutation represents an operation that mutates the EmailProvider nodes in the graph.
type EmailProviderMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	provider                *string
	api_key                 *string
	sender_email            *string
	sender_name             *string
	status                  *string
	last_checked_at         *time.Time
	last_error              *string
	consecutive_failures    *int
	addconsecutive_failures *int
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*EmailProvider, error)
	predicates              []predicate.EmailProvider
}

var _ ent.Mutation = (*EmailProviderMutation)(nil)

// emailproviderOption allows management of the mutation configuration using functional options.
type emailproviderOption func(*EmailProviderMutation)

// newEmailProviderMutation creates new mutation for the EmailProvider entity.
func newEmailProviderMutation(c config, op Op, opts ...emailproviderOption) *EmailProviderMutation {
	m := &EmailProviderMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailProvider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailProviderID sets the ID field of the mutation.
func withEmailProviderID(id int64) emailproviderOption {
	return func(m *EmailProviderMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailProvider
		)
		m.oldValue = func(ctx context.Context) (*EmailProvider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailProvider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailProvider sets the old EmailProvider of the mutation.
func withEmailProvider(node *EmailProvider) emailproviderOption {
	return func(m *EmailProviderMutation) {
		m.oldValue = func(context.Context) (*EmailProvider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailProviderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailProviderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailProvider entities.
func (m *EmailProviderMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailProviderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailProviderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailProvider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProvider sets the "provider" field.
func (m *EmailProviderMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *EmailProviderMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ResetProvider resets all changes to the "provider" field.
func (m *EmailProviderMutation) ResetProvider() {
	m.provider = nil
}

// SetAPIKey sets the "api_key" field.
func (m *EmailProviderMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *EmailProviderMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *EmailProviderMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetSenderEmail sets the "sender_email" field.
func (m *EmailProviderMutation) SetSenderEmail(s string) {
	m.sender_email = &s
}

// SenderEmail returns the value of the "sender_email" field in the mutation.
func (m *EmailProviderMutation) SenderEmail() (r string, exists bool) {
	v := m.sender_email
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderEmail returns the old "sender_email" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldSenderEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderEmail: %w", err)
	}
	return oldValue.SenderEmail, nil
}

// ResetSenderEmail resets all changes to the "sender_email" field.
func (m *EmailProviderMutation) ResetSenderEmail() {
	m.sender_email = nil
}

// SetSenderName sets the "sender_name" field.
func (m *EmailProviderMutation) SetSenderName(s string) {
	m.sender_name = &s
}

// SenderName returns the value of the "sender_name" field in the mutation.
func (m *EmailProviderMutation) SenderName() (r string, exists bool) {
	v := m.sender_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderName returns the old "sender_name" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldSenderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderName: %w", err)
	}
	return oldValue.SenderName, nil
}

// ResetSenderName resets all changes to the "sender_name" field.
func (m *EmailProviderMutation) ResetSenderName() {
	m.sender_name = nil
}

// SetStatus sets the "status" field.
func (m *EmailProviderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EmailProviderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EmailProviderMutation) ResetStatus() {
	m.status = nil
}

// SetLastCheckedAt sets the "last_checked_at" field.
func (m *EmailProviderMutation) SetLastCheckedAt(t time.Time) {
	m.last_checked_at = &t
}

// LastCheckedAt returns the value of the "last_checked_at" field in the mutation.
func (m *EmailProviderMutation) LastCheckedAt() (r time.Time, exists bool) {
	v := m.last_checked_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCheckedAt returns the old "last_checked_at" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldLastCheckedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCheckedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCheckedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCheckedAt: %w", err)
	}
	return oldValue.LastCheckedAt, nil
}

// ClearLastCheckedAt clears the value of the "last_checked_at" field.
func (m *EmailProviderMutation) ClearLastCheckedAt() {
	m.last_checked_at = nil
	m.clearedFields[emailprovider.FieldLastCheckedAt] = struct{}{}
}

// LastCheckedAtCleared returns if the "last_checked_at" field was cleared in this mutation.
func (m *EmailProviderMutation) LastCheckedAtCleared() bool {
	_, ok := m.clearedFields[emailprovider.FieldLastCheckedAt]
	return ok
}

// ResetLastCheckedAt resets all changes to the "last_checked_at" field.
func (m *EmailProviderMutation) ResetLastCheckedAt() {
	m.last_checked_at = nil
	delete(m.clearedFields, emailprovider.FieldLastCheckedAt)
}

// SetLastError sets the "last_error" field.
func (m *EmailProviderMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *EmailProviderMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldLastError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ResetLastError resets all changes to the "last_error" field.
func (m *EmailProviderMutation) ResetLastError() {
	m.last_error = nil
}

// SetConsecutiveFailures sets the "consecutive_failures" field.
func (m *EmailProviderMutation) SetConsecutiveFailures(i int) {
	m.consecutive_failures = &i
	m.addconsecutive_failures = nil
}

// ConsecutiveFailures returns the value of the "consecutive_failures" field in the mutation.
func (m *EmailProviderMutation) ConsecutiveFailures() (r int, exists bool) {
	v := m.consecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// OldConsecutiveFailures returns the old "consecutive_failures" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldConsecutiveFailures(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsecutiveFailures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsecutiveFailures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsecutiveFailures: %w", err)
	}
	return oldValue.ConsecutiveFailures, nil
}

// AddConsecutiveFailures adds i to the "consecutive_failures" field.
func (m *EmailProviderMutation) AddConsecutiveFailures(i int) {
	if m.addconsecutive_failures != nil {
		*m.addconsecutive_failures += i
	} else {
		m.addconsecutive_failures = &i
	}
}

// AddedConsecutiveFailures returns the value that was added to the "consecutive_failures" field in this mutation.
func (m *EmailProviderMutation) AddedConsecutiveFailures() (r int, exists bool) {
	v := m.addconsecutive_failures
	if v == nil {
		return
	}
	return *v, true
}

// ResetConsecutiveFailures resets all changes to the "consecutive_failures" field.
func (m *EmailProviderMutation) ResetConsecutiveFailures() {
	m.consecutive_failures = nil
	m.addconsecutive_failures = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailProviderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailProviderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailProviderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailProviderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailProviderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailProvider entity.
// If the EmailProvider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailProviderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailProviderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the EmailProviderMutation builder.
func (m *EmailProviderMutation) Where(ps ...predicate.EmailProvider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailProviderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailProviderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailProvider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailProviderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailProviderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailProvider).
func (m *EmailProviderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailProviderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.provider != nil {
		fields = append(fields, emailprovider.FieldProvider)
	}
	if m.api_key != nil {
		fields = append(fields, emailprovider.FieldAPIKey)
	}
	if m.sender_email != nil {
		fields = append(fields, emailprovider.FieldSenderEmail)
	}
	if m.sender_name != nil {
		fields = append(fields, emailprovider.FieldSenderName)
	}
	if m.status != nil {
		fields = append(fields, emailprovider.FieldStatus)
	}
	if m.last_checked_at != nil {
		fields = append(fields, emailprovider.FieldLastCheckedAt)
	}
	if m.last_error != nil {
		fields = append(fields, emailprovider.FieldLastError)
	}
	if m.consecutive_failures != nil {
		fields = append(fields, emailprovider.FieldConsecutiveFailures)
	}
	if m.created_at != nil {
		fields = append(fields, emailprovider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailprovider.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailProviderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailprovider.FieldProvider:
		return m.Provider()
	case emailprovider.FieldAPIKey:
		return m.APIKey()
	case emailprovider.FieldSenderEmail:
		return m.SenderEmail()
	case emailprovider.FieldSenderName:
		return m.SenderName()
	case emailprovider.FieldStatus:
		return m.Status()
	case emailprovider.FieldLastCheckedAt:
		return m.LastCheckedAt()
	case emailprovider.FieldLastError:
		return m.LastError()
	case emailprovider.FieldConsecutiveFailures:
		return m.ConsecutiveFailures()
	case emailprovider.FieldCreatedAt:
		return m.CreatedAt()
	case emailprovider.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailProviderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailprovider.FieldProvider:
		return m.OldProvider(ctx)
	case emailprovider.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case emailprovider.FieldSenderEmail:
		return m.OldSenderEmail(ctx)
	case emailprovider.FieldSenderName:
		return m.OldSenderName(ctx)
	case emailprovider.FieldStatus:
		return m.OldStatus(ctx)
	case emailprovider.FieldLastCheckedAt:
		return m.OldLastCheckedAt(ctx)
	case emailprovider.FieldLastError:
		return m.OldLastError(ctx)
	case emailprovider.FieldConsecutiveFailures:
		return m.OldConsecutiveFailures(ctx)
	case emailprovider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailprovider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailProvider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProviderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailprovider.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case emailprovider.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case emailprovider.FieldSenderEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderEmail(v)
		return nil
	case emailprovider.FieldSenderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderName(v)
		return nil
	case emailprovider.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case emailprovider.FieldLastCheckedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCheckedAt(v)
		return nil
	case emailprovider.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	case emailprovider.FieldConsecutiveFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsecutiveFailures(v)
		return nil
	case emailprovider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailprovider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProvider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailProviderMutation) AddedFields() []string {
	var fields []string
	if m.addconsecutive_failures != nil {
		fields = append(fields, emailprovider.FieldConsecutiveFailures)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailProviderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emailprovider.FieldConsecutiveFailures:
		return m.AddedConsecutiveFailures()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailProviderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emailprovider.FieldConsecutiveFailures:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConsecutiveFailures(v)
		return nil
	}
	return fmt.Errorf("unknown EmailProvider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailProviderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailprovider.FieldLastCheckedAt) {
		fields = append(fields, emailprovider.FieldLastCheckedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailProviderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailProviderMutation) ClearField(name string) error {
	switch name {
	case emailprovider.FieldLastCheckedAt:
		m.ClearLastCheckedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailProvider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailProviderMutation) ResetField(name string) error {
	switch name {
	case emailprovider.FieldProvider:
		m.ResetProvider()
		return nil
	case emailprovider.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case emailprovider.FieldSenderEmail:
		m.ResetSenderEmail()
		return nil
	case emailprovider.FieldSenderName:
		m.ResetSenderName()
		return nil
	case emailprovider.FieldStatus:
		m.ResetStatus()
		return nil
	case emailprovider.FieldLastCheckedAt:
		m.ResetLastCheckedAt()
		return nil
	case emailprovider.FieldLastError:
		m.ResetLastError()
		return nil
	case emailprovider.FieldConsecutiveFailures:
		m.ResetConsecutiveFailures()
		return nil
	case emailprovider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailprovider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailProvider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailProviderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailProviderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailProviderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailProviderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailProviderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailProviderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailProviderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EmailProvider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailProviderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EmailProvider edge %s", name)
}

// InviteMutation represents an operation that mutates the Invite nodes in the graph.
type InviteMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	code           *string
	used_at        *time.Time
	expires_at     *time.Time
	created_at     *time.Time
	clearedFields  map[string]struct{}
	inviter        *int64
	clearedinviter bool
	invitee        *int64
	clearedinvitee bool
	done           bool
	oldValue       func(context.Context) (*Invite, error)
	predicates     []predicate.Invite
}

var _ ent.Mutation = (*InviteMutation)(nil)

// inviteOption allows management of the mutation configuration using functional options.
type inviteOption func(*InviteMutation)

// newInviteMutation creates new mutation for the Invite entity.
func newInviteMutation(c config, op Op, opts ...inviteOption) *InviteMutation {
	m := &InviteMutation{
		config:        c,
		op:            op,
		typ:           TypeInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInviteID sets the ID field of the mutation.
func withInviteID(id int64) inviteOption {
	return func(m *InviteMutation) {
		var (
			err   error
			once  sync.Once
			value *Invite
		)
		m.oldValue = func(ctx context.Context) (*Invite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvite sets the old Invite of the mutation.
func withInvite(node *Invite) inviteOption {
	return func(m *InviteMutation) {
		m.oldValue = func(context.Context) (*Invite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invite entities.
func (m *InviteMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InviteMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InviteMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *InviteMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *InviteMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *InviteMutation) ResetCode() {
	m.code = nil
}

// SetInviterID sets the "inviter_id" field.
func (m *InviteMutation) SetInviterID(i int64) {
	m.inviter = &i
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *InviteMutation) InviterID() (r int64, exists bool) {
	v := m.inviter
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldInviterID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *InviteMutation) ResetInviterID() {
	m.inviter = nil
}

// SetInviteeID sets the "invitee_id" field.
func (m *InviteMutation) SetInviteeID(i int64) {
	m.invitee = &i
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *InviteMutation) InviteeID() (r int64, exists bool) {
	v := m.invitee
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldInviteeID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ClearInviteeID clears the value of the "invitee_id" field.
func (m *InviteMutation) ClearInviteeID() {
	m.invitee = nil
	m.clearedFields[invite.FieldInviteeID] = struct{}{}
}

// InviteeIDCleared returns if the "invitee_id" field was cleared in this mutation.
func (m *InviteMutation) InviteeIDCleared() bool {
	_, ok := m.clearedFields[invite.FieldInviteeID]
	return ok
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *InviteMutation) ResetInviteeID() {
	m.invitee = nil
	delete(m.clearedFields, invite.FieldInviteeID)
}

// SetUsedAt sets the "used_at" field.
func (m *InviteMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *InviteMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *InviteMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[invite.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *InviteMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *InviteMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, invite.FieldUsedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *InviteMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *InviteMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *InviteMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[invite.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *InviteMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[invite.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *InviteMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, invite.FieldExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *InviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Invite entity.
// If the Invite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InviteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearInviter clears the "inviter" edge to the User entity.
func (m *InviteMutation) ClearInviter() {
	m.clearedinviter = true
	m.clearedFields[invite.FieldInviterID] = struct{}{}
}

// InviterCleared reports if the "inviter" edge to the User entity was cleared.
func (m *InviteMutation) InviterCleared() bool {
	return m.clearedinviter
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) InviterIDs() (ids []int64) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *InviteMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// ClearInvitee clears the "invitee" edge to the User entity.
func (m *InviteMutation) ClearInvitee() {
	m.clearedinvitee = true
	m.clearedFields[invite.FieldInviteeID] = struct{}{}
}

// InviteeCleared reports if the "invitee" edge to the User entity was cleared.
func (m *InviteMutation) InviteeCleared() bool {
	return m.InviteeIDCleared() || m.clearedinvitee
}

// InviteeIDs returns the "invitee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteeID instead. It exists only for internal usage by the builders.
func (m *InviteMutation) InviteeIDs() (ids []int64) {
	if id := m.invitee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitee resets all changes to the "invitee" edge.
func (m *InviteMutation) ResetInvitee() {
	m.invitee = nil
	m.clearedinvitee = false
}

// Where appends a list predicates to the InviteMutation builder.
func (m *InviteMutation) Where(ps ...predicate.Invite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invite).
func (m *InviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InviteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.code != nil {
		fields = append(fields, invite.FieldCode)
	}
	if m.inviter != nil {
		fields = append(fields, invite.FieldInviterID)
	}
	if m.invitee != nil {
		fields = append(fields, invite.FieldInviteeID)
	}
	if m.used_at != nil {
		fields = append(fields, invite.FieldUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, invite.FieldExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, invite.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invite.FieldCode:
		return m.Code()
	case invite.FieldInviterID:
		return m.InviterID()
	case invite.FieldInviteeID:
		return m.InviteeID()
	case invite.FieldUsedAt:
		return m.UsedAt()
	case invite.FieldExpiresAt:
		return m.ExpiresAt()
	case invite.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invite.FieldCode:
		return m.OldCode(ctx)
	case invite.FieldInviterID:
		return m.OldInviterID(ctx)
	case invite.FieldInviteeID:
		return m.OldInviteeID(ctx)
	case invite.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case invite.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case invite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Invite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invite.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case invite.FieldInviterID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case invite.FieldInviteeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	case invite.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case invite.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case invite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InviteMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InviteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(invite.FieldInviteeID) {
		fields = append(fields, invite.FieldInviteeID)
	}
	if m.FieldCleared(invite.FieldUsedAt) {
		fields = append(fields, invite.FieldUsedAt)
	}
	if m.FieldCleared(invite.FieldExpiresAt) {
		fields = append(fields, invite.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InviteMutation) ClearField(name string) error {
	switch name {
	case invite.FieldInviteeID:
		m.ClearInviteeID()
		return nil
	case invite.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case invite.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Invite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InviteMutation) ResetField(name string) error {
	switch name {
	case invite.FieldCode:
		m.ResetCode()
		return nil
	case invite.FieldInviterID:
		m.ResetInviterID()
		return nil
	case invite.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	case invite.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case invite.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case invite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Invite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.inviter != nil {
		edges = append(edges, invite.EdgeInviter)
	}
	if m.invitee != nil {
		edges = append(edges, invite.EdgeInvitee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invite.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	case invite.EdgeInvitee:
		if id := m.invitee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinviter {
		edges = append(edges, invite.EdgeInviter)
	}
	if m.clearedinvitee {
		edges = append(edges, invite.EdgeInvitee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InviteMutation) EdgeCleared(name string) bool {
	switch name {
	case invite.EdgeInviter:
		return m.clearedinviter
	case invite.EdgeInvitee:
		return m.clearedinvitee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InviteMutation) ClearEdge(name string) error {
	switch name {
	case invite.EdgeInviter:
		m.ClearInviter()
		return nil
	case invite.EdgeInvitee:
		m.ClearInvitee()
		return nil
	}
	return fmt.Errorf("unknown Invite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InviteMutation) ResetEdge(name string) error {
	switch name {
	case invite.EdgeInviter:
		m.ResetInviter()
		return nil
	case invite.EdgeInvitee:
		m.ResetInvitee()
		return nil
	}
	return fmt.Errorf("unknown Invite edge %s", name)
}

// PageVersionMutation represents an operation that mutates the PageVersion nodes in the graph.
type PageVersionMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	version_number    *int
	addversion_number *int
	yjs_state         *[]byte
	created_at        *time.Time
	clearedFields     map[string]struct{}
	page              *int64
	clearedpage       bool
	done              bool
	oldValue          func(context.Context) (*PageVersion, error)
	predicates        []predicate.PageVersion
}

var _ ent.Mutation = (*PageVersionMutation)(nil)

// pageversionOption allows management of the mutation configuration using functional options.
type pageversionOption func(*PageVersionMutation)

// newPageVersionMutation creates new mutation for the PageVersion entity.
func newPageVersionMutation(c config, op Op, opts ...pageversionOption) *PageVersionMutation {
	m := &PageVersionMutation{
		config:        c,
		op:            op,
		typ:           TypePageVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPageVersionID sets the ID field of the mutation.
func withPageVersionID(id int64) pageversionOption {
	return func(m *PageVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *PageVersion
		)
		m.oldValue = func(ctx context.Context) (*PageVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PageVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPageVersion sets the old PageVersion of the mutation.
func withPageVersion(node *PageVersion) pageversionOption {
	return func(m *PageVersionMutation) {
		m.oldValue = func(context.Context) (*PageVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PageVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PageVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PageVersion entities.
func (m *PageVersionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PageVersionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PageVersionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PageVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPageID sets the "page_id" field.
func (m *PageVersionMutation) SetPageID(i int64) {
	m.page = &i
}

// PageID returns the value of the "page_id" field in the mutation.
func (m *PageVersionMutation) PageID() (r int64, exists bool) {
	v := m.page
	if v == nil {
		return
	}
	return *v, true
}

// OldPageID returns the old "page_id" field's value of the PageVersion entity.
// If the PageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVersionMutation) OldPageID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageID: %w", err)
	}
	return oldValue.PageID, nil
}

// ResetPageID resets all changes to the "page_id" field.
func (m *PageVersionMutation) ResetPageID() {
	m.page = nil
}

// SetVersionNumber sets the "version_number" field.
func (m *PageVersionMutation) SetVersionNumber(i int) {
	m.version_number = &i
	m.addversion_number = nil
}

// VersionNumber returns the value of the "version_number" field in the mutation.
func (m *PageVersionMutation) VersionNumber() (r int, exists bool) {
	v := m.version_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVersionNumber returns the old "version_number" field's value of the PageVersion entity.
// If the PageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVersionMutation) OldVersionNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersionNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersionNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersionNumber: %w", err)
	}
	return oldValue.VersionNumber, nil
}

// AddVersionNumber adds i to the "version_number" field.
func (m *PageVersionMutation) AddVersionNumber(i int) {
	if m.addversion_number != nil {
		*m.addversion_number += i
	} else {
		m.addversion_number = &i
	}
}

// AddedVersionNumber returns the value that was added to the "version_number" field in this mutation.
func (m *PageVersionMutation) AddedVersionNumber() (r int, exists bool) {
	v := m.addversion_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetVersionNumber resets all changes to the "version_number" field.
func (m *PageVersionMutation) ResetVersionNumber() {
	m.version_number = nil
	m.addversion_number = nil
}

// SetYjsState sets the "yjs_state" field.
func (m *PageVersionMutation) SetYjsState(b []byte) {
	m.yjs_state = &b
}

// YjsState returns the value of the "yjs_state" field in the mutation.
func (m *PageVersionMutation) YjsState() (r []byte, exists bool) {
	v := m.yjs_state
	if v == nil {
		return
	}
	return *v, true
}

// OldYjsState returns the old "yjs_state" field's value of the PageVersion entity.
// If the PageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVersionMutation) OldYjsState(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYjsState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYjsState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYjsState: %w", err)
	}
	return oldValue.YjsState, nil
}

// ResetYjsState resets all changes to the "yjs_state" field.
func (m *PageVersionMutation) ResetYjsState() {
	m.yjs_state = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PageVersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PageVersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PageVersion entity.
// If the PageVersion object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PageVersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PageVersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearPage clears the "page" edge to the WikiPage entity.
func (m *PageVersionMutation) ClearPage() {
	m.clearedpage = true
	m.clearedFields[pageversion.FieldPageID] = struct{}{}
}

// PageCleared reports if the "page" edge to the WikiPage entity was cleared.
func (m *PageVersionMutation) PageCleared() bool {
	return m.clearedpage
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *PageVersionMutation) PageIDs() (ids []int64) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *PageVersionMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// Where appends a list predicates to the PageVersionMutation builder.
func (m *PageVersionMutation) Where(ps ...predicate.PageVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PageVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PageVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PageVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PageVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PageVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PageVersion).
func (m *PageVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PageVersionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.page != nil {
		fields = append(fields, pageversion.FieldPageID)
	}
	if m.version_number != nil {
		fields = append(fields, pageversion.FieldVersionNumber)
	}
	if m.yjs_state != nil {
		fields = append(fields, pageversion.FieldYjsState)
	}
	if m.created_at != nil {
		fields = append(fields, pageversion.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PageVersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pageversion.FieldPageID:
		return m.PageID()
	case pageversion.FieldVersionNumber:
		return m.VersionNumber()
	case pageversion.FieldYjsState:
		return m.YjsState()
	case pageversion.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PageVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pageversion.FieldPageID:
		return m.OldPageID(ctx)
	case pageversion.FieldVersionNumber:
		return m.OldVersionNumber(ctx)
	case pageversion.FieldYjsState:
		return m.OldYjsState(ctx)
	case pageversion.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PageVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pageversion.FieldPageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageID(v)
		return nil
	case pageversion.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersionNumber(v)
		return nil
	case pageversion.FieldYjsState:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYjsState(v)
		return nil
	case pageversion.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PageVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PageVersionMutation) AddedFields() []string {
	var fields []string
	if m.addversion_number != nil {
		fields = append(fields, pageversion.FieldVersionNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PageVersionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pageversion.FieldVersionNumber:
		return m.AddedVersionNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PageVersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pageversion.FieldVersionNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVersionNumber(v)
		return nil
	}
	return fmt.Errorf("unknown PageVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PageVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PageVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PageVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PageVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PageVersionMutation) ResetField(name string) error {
	switch name {
	case pageversion.FieldPageID:
		m.ResetPageID()
		return nil
	case pageversion.FieldVersionNumber:
		m.ResetVersionNumber()
		return nil
	case pageversion.FieldYjsState:
		m.ResetYjsState()
		return nil
	case pageversion.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PageVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PageVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page != nil {
		edges = append(edges, pageversion.EdgePage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PageVersionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pageversion.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PageVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PageVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PageVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpage {
		edges = append(edges, pageversion.EdgePage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PageVersionMutation) EdgeCleared(name string) bool {
	switch name {
	case pageversion.EdgePage:
		return m.clearedpage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PageVersionMutation) ClearEdge(name string) error {
	switch name {
	case pageversion.EdgePage:
		m.ClearPage()
		return nil
	}
	return fmt.Errorf("unknown PageVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PageVersionMutation) ResetEdge(name string) error {
	switch name {
	case pageversion.EdgePage:
		m.ResetPage()
		return nil
	}
	return fmt.Errorf("unknown PageVersion edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	name                *string
	description         *string
	github_repo_url     *string
	github_owner        *string
	github_repo_name    *string
	github_branch       *string
	github_sync_enabled *bool
	github_last_sync    *time.Time
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	owner               *int64
	clearedowner        bool
	team                *int64
	clearedteam         bool
	members             map[int64]struct{}
	removedmembers      map[int64]struct{}
	clearedmembers      bool
	tasks               map[int64]struct{}
	removedtasks        map[int64]struct{}
	clearedtasks        bool
	swim_lanes          map[int64]struct{}
	removedswim_lanes   map[int64]struct{}
	clearedswim_lanes   bool
	attachments         map[int64]struct{}
	removedattachments  map[int64]struct{}
	clearedattachments  bool
	wiki_pages          map[int64]struct{}
	removedwiki_pages   map[int64]struct{}
	clearedwiki_pages   bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int64) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Project entities.
func (m *ProjectMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Project.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwnerID sets the "owner_id" field.
func (m *ProjectMutation) SetOwnerID(i int64) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *ProjectMutation) OwnerID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *ProjectMutation) ResetOwnerID() {
	m.owner = nil
}

// SetTeamID sets the "team_id" field.
func (m *ProjectMutation) SetTeamID(i int64) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *ProjectMutation) TeamID() (r int64, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTeamID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *ProjectMutation) ClearTeamID() {
	m.team = nil
	m.clearedFields[project.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *ProjectMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[project.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *ProjectMutation) ResetTeamID() {
	m.team = nil
	delete(m.clearedFields, project.FieldTeamID)
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[project.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[project.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, project.FieldDescription)
}

// SetGithubRepoURL sets the "github_repo_url" field.
func (m *ProjectMutation) SetGithubRepoURL(s string) {
	m.github_repo_url = &s
}

// GithubRepoURL returns the value of the "github_repo_url" field in the mutation.
func (m *ProjectMutation) GithubRepoURL() (r string, exists bool) {
	v := m.github_repo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubRepoURL returns the old "github_repo_url" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubRepoURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubRepoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubRepoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubRepoURL: %w", err)
	}
	return oldValue.GithubRepoURL, nil
}

// ClearGithubRepoURL clears the value of the "github_repo_url" field.
func (m *ProjectMutation) ClearGithubRepoURL() {
	m.github_repo_url = nil
	m.clearedFields[project.FieldGithubRepoURL] = struct{}{}
}

// GithubRepoURLCleared returns if the "github_repo_url" field was cleared in this mutation.
func (m *ProjectMutation) GithubRepoURLCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubRepoURL]
	return ok
}

// ResetGithubRepoURL resets all changes to the "github_repo_url" field.
func (m *ProjectMutation) ResetGithubRepoURL() {
	m.github_repo_url = nil
	delete(m.clearedFields, project.FieldGithubRepoURL)
}

// SetGithubOwner sets the "github_owner" field.
func (m *ProjectMutation) SetGithubOwner(s string) {
	m.github_owner = &s
}

// GithubOwner returns the value of the "github_owner" field in the mutation.
func (m *ProjectMutation) GithubOwner() (r string, exists bool) {
	v := m.github_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubOwner returns the old "github_owner" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubOwner(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubOwner: %w", err)
	}
	return oldValue.GithubOwner, nil
}

// ClearGithubOwner clears the value of the "github_owner" field.
func (m *ProjectMutation) ClearGithubOwner() {
	m.github_owner = nil
	m.clearedFields[project.FieldGithubOwner] = struct{}{}
}

// GithubOwnerCleared returns if the "github_owner" field was cleared in this mutation.
func (m *ProjectMutation) GithubOwnerCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubOwner]
	return ok
}

// ResetGithubOwner resets all changes to the "github_owner" field.
func (m *ProjectMutation) ResetGithubOwner() {
	m.github_owner = nil
	delete(m.clearedFields, project.FieldGithubOwner)
}

// SetGithubRepoName sets the "github_repo_name" field.
func (m *ProjectMutation) SetGithubRepoName(s string) {
	m.github_repo_name = &s
}

// GithubRepoName returns the value of the "github_repo_name" field in the mutation.
func (m *ProjectMutation) GithubRepoName() (r string, exists bool) {
	v := m.github_repo_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubRepoName returns the old "github_repo_name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubRepoName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubRepoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubRepoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubRepoName: %w", err)
	}
	return oldValue.GithubRepoName, nil
}

// ClearGithubRepoName clears the value of the "github_repo_name" field.
func (m *ProjectMutation) ClearGithubRepoName() {
	m.github_repo_name = nil
	m.clearedFields[project.FieldGithubRepoName] = struct{}{}
}

// GithubRepoNameCleared returns if the "github_repo_name" field was cleared in this mutation.
func (m *ProjectMutation) GithubRepoNameCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubRepoName]
	return ok
}

// ResetGithubRepoName resets all changes to the "github_repo_name" field.
func (m *ProjectMutation) ResetGithubRepoName() {
	m.github_repo_name = nil
	delete(m.clearedFields, project.FieldGithubRepoName)
}

// SetGithubBranch sets the "github_branch" field.
func (m *ProjectMutation) SetGithubBranch(s string) {
	m.github_branch = &s
}

// GithubBranch returns the value of the "github_branch" field in the mutation.
func (m *ProjectMutation) GithubBranch() (r string, exists bool) {
	v := m.github_branch
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubBranch returns the old "github_branch" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubBranch(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubBranch: %w", err)
	}
	return oldValue.GithubBranch, nil
}

// ResetGithubBranch resets all changes to the "github_branch" field.
func (m *ProjectMutation) ResetGithubBranch() {
	m.github_branch = nil
}

// SetGithubSyncEnabled sets the "github_sync_enabled" field.
func (m *ProjectMutation) SetGithubSyncEnabled(b bool) {
	m.github_sync_enabled = &b
}

// GithubSyncEnabled returns the value of the "github_sync_enabled" field in the mutation.
func (m *ProjectMutation) GithubSyncEnabled() (r bool, exists bool) {
	v := m.github_sync_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubSyncEnabled returns the old "github_sync_enabled" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubSyncEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubSyncEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubSyncEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubSyncEnabled: %w", err)
	}
	return oldValue.GithubSyncEnabled, nil
}

// ResetGithubSyncEnabled resets all changes to the "github_sync_enabled" field.
func (m *ProjectMutation) ResetGithubSyncEnabled() {
	m.github_sync_enabled = nil
}

// SetGithubLastSync sets the "github_last_sync" field.
func (m *ProjectMutation) SetGithubLastSync(t time.Time) {
	m.github_last_sync = &t
}

// GithubLastSync returns the value of the "github_last_sync" field in the mutation.
func (m *ProjectMutation) GithubLastSync() (r time.Time, exists bool) {
	v := m.github_last_sync
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubLastSync returns the old "github_last_sync" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldGithubLastSync(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubLastSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubLastSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubLastSync: %w", err)
	}
	return oldValue.GithubLastSync, nil
}

// ClearGithubLastSync clears the value of the "github_last_sync" field.
func (m *ProjectMutation) ClearGithubLastSync() {
	m.github_last_sync = nil
	m.clearedFields[project.FieldGithubLastSync] = struct{}{}
}

// GithubLastSyncCleared returns if the "github_last_sync" field was cleared in this mutation.
func (m *ProjectMutation) GithubLastSyncCleared() bool {
	_, ok := m.clearedFields[project.FieldGithubLastSync]
	return ok
}

// ResetGithubLastSync resets all changes to the "github_last_sync" field.
func (m *ProjectMutation) ResetGithubLastSync() {
	m.github_last_sync = nil
	delete(m.clearedFields, project.FieldGithubLastSync)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *ProjectMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[project.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *ProjectMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *ProjectMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *ProjectMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[project.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *ProjectMutation) TeamCleared() bool {
	return m.TeamIDCleared() || m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *ProjectMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddMemberIDs adds the "members" edge to the ProjectMember entity by ids.
func (m *ProjectMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the ProjectMember entity.
func (m *ProjectMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the ProjectMember entity was cleared.
func (m *ProjectMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the ProjectMember entity by IDs.
func (m *ProjectMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the ProjectMember entity.
func (m *ProjectMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *ProjectMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *ProjectMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *ProjectMutation) AddTaskIDs(ids ...int64) {
	if m.tasks == nil {
		m.tasks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *ProjectMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *ProjectMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *ProjectMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *ProjectMutation) RemovedTasksIDs() (ids []int64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *ProjectMutation) TasksIDs() (ids []int64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *ProjectMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// AddSwimLaneIDs adds the "swim_lanes" edge to the SwimLane entity by ids.
func (m *ProjectMutation) AddSwimLaneIDs(ids ...int64) {
	if m.swim_lanes == nil {
		m.swim_lanes = make(map[int64]struct{})
	}
	for i := range ids {
		m.swim_lanes[ids[i]] = struct{}{}
	}
}

// ClearSwimLanes clears the "swim_lanes" edge to the SwimLane entity.
func (m *ProjectMutation) ClearSwimLanes() {
	m.clearedswim_lanes = true
}

// SwimLanesCleared reports if the "swim_lanes" edge to the SwimLane entity was cleared.
func (m *ProjectMutation) SwimLanesCleared() bool {
	return m.clearedswim_lanes
}

// RemoveSwimLaneIDs removes the "swim_lanes" edge to the SwimLane entity by IDs.
func (m *ProjectMutation) RemoveSwimLaneIDs(ids ...int64) {
	if m.removedswim_lanes == nil {
		m.removedswim_lanes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.swim_lanes, ids[i])
		m.removedswim_lanes[ids[i]] = struct{}{}
	}
}

// RemovedSwimLanes returns the removed IDs of the "swim_lanes" edge to the SwimLane entity.
func (m *ProjectMutation) RemovedSwimLanesIDs() (ids []int64) {
	for id := range m.removedswim_lanes {
		ids = append(ids, id)
	}
	return
}

// SwimLanesIDs returns the "swim_lanes" edge IDs in the mutation.
func (m *ProjectMutation) SwimLanesIDs() (ids []int64) {
	for id := range m.swim_lanes {
		ids = append(ids, id)
	}
	return
}

// ResetSwimLanes resets all changes to the "swim_lanes" edge.
func (m *ProjectMutation) ResetSwimLanes() {
	m.swim_lanes = nil
	m.clearedswim_lanes = false
	m.removedswim_lanes = nil
}

// AddAttachmentIDs adds the "attachments" edge to the TaskAttachment entity by ids.
func (m *ProjectMutation) AddAttachmentIDs(ids ...int64) {
	if m.attachments == nil {
		m.attachments = make(map[int64]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the TaskAttachment entity.
func (m *ProjectMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the TaskAttachment entity was cleared.
func (m *ProjectMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the TaskAttachment entity by IDs.
func (m *ProjectMutation) RemoveAttachmentIDs(ids ...int64) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the TaskAttachment entity.
func (m *ProjectMutation) RemovedAttachmentsIDs() (ids []int64) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *ProjectMutation) AttachmentsIDs() (ids []int64) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *ProjectMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddWikiPageIDs adds the "wiki_pages" edge to the WikiPage entity by ids.
func (m *ProjectMutation) AddWikiPageIDs(ids ...int64) {
	if m.wiki_pages == nil {
		m.wiki_pages = make(map[int64]struct{})
	}
	for i := range ids {
		m.wiki_pages[ids[i]] = struct{}{}
	}
}

// ClearWikiPages clears the "wiki_pages" edge to the WikiPage entity.
func (m *ProjectMutation) ClearWikiPages() {
	m.clearedwiki_pages = true
}

// WikiPagesCleared reports if the "wiki_pages" edge to the WikiPage entity was cleared.
func (m *ProjectMutation) WikiPagesCleared() bool {
	return m.clearedwiki_pages
}

// RemoveWikiPageIDs removes the "wiki_pages" edge to the WikiPage entity by IDs.
func (m *ProjectMutation) RemoveWikiPageIDs(ids ...int64) {
	if m.removedwiki_pages == nil {
		m.removedwiki_pages = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wiki_pages, ids[i])
		m.removedwiki_pages[ids[i]] = struct{}{}
	}
}

// RemovedWikiPages returns the removed IDs of the "wiki_pages" edge to the WikiPage entity.
func (m *ProjectMutation) RemovedWikiPagesIDs() (ids []int64) {
	for id := range m.removedwiki_pages {
		ids = append(ids, id)
	}
	return
}

// WikiPagesIDs returns the "wiki_pages" edge IDs in the mutation.
func (m *ProjectMutation) WikiPagesIDs() (ids []int64) {
	for id := range m.wiki_pages {
		ids = append(ids, id)
	}
	return
}

// ResetWikiPages resets all changes to the "wiki_pages" edge.
func (m *ProjectMutation) ResetWikiPages() {
	m.wiki_pages = nil
	m.clearedwiki_pages = false
	m.removedwiki_pages = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Project, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.owner != nil {
		fields = append(fields, project.FieldOwnerID)
	}
	if m.team != nil {
		fields = append(fields, project.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.description != nil {
		fields = append(fields, project.FieldDescription)
	}
	if m.github_repo_url != nil {
		fields = append(fields, project.FieldGithubRepoURL)
	}
	if m.github_owner != nil {
		fields = append(fields, project.FieldGithubOwner)
	}
	if m.github_repo_name != nil {
		fields = append(fields, project.FieldGithubRepoName)
	}
	if m.github_branch != nil {
		fields = append(fields, project.FieldGithubBranch)
	}
	if m.github_sync_enabled != nil {
		fields = append(fields, project.FieldGithubSyncEnabled)
	}
	if m.github_last_sync != nil {
		fields = append(fields, project.FieldGithubLastSync)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, project.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldOwnerID:
		return m.OwnerID()
	case project.FieldTeamID:
		return m.TeamID()
	case project.FieldName:
		return m.Name()
	case project.FieldDescription:
		return m.Description()
	case project.FieldGithubRepoURL:
		return m.GithubRepoURL()
	case project.FieldGithubOwner:
		return m.GithubOwner()
	case project.FieldGithubRepoName:
		return m.GithubRepoName()
	case project.FieldGithubBranch:
		return m.GithubBranch()
	case project.FieldGithubSyncEnabled:
		return m.GithubSyncEnabled()
	case project.FieldGithubLastSync:
		return m.GithubLastSync()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case project.FieldTeamID:
		return m.OldTeamID(ctx)
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldDescription:
		return m.OldDescription(ctx)
	case project.FieldGithubRepoURL:
		return m.OldGithubRepoURL(ctx)
	case project.FieldGithubOwner:
		return m.OldGithubOwner(ctx)
	case project.FieldGithubRepoName:
		return m.OldGithubRepoName(ctx)
	case project.FieldGithubBranch:
		return m.OldGithubBranch(ctx)
	case project.FieldGithubSyncEnabled:
		return m.OldGithubSyncEnabled(ctx)
	case project.FieldGithubLastSync:
		return m.OldGithubLastSync(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case project.FieldTeamID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case project.FieldGithubRepoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubRepoURL(v)
		return nil
	case project.FieldGithubOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubOwner(v)
		return nil
	case project.FieldGithubRepoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubRepoName(v)
		return nil
	case project.FieldGithubBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubBranch(v)
		return nil
	case project.FieldGithubSyncEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubSyncEnabled(v)
		return nil
	case project.FieldGithubLastSync:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubLastSync(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldTeamID) {
		fields = append(fields, project.FieldTeamID)
	}
	if m.FieldCleared(project.FieldDescription) {
		fields = append(fields, project.FieldDescription)
	}
	if m.FieldCleared(project.FieldGithubRepoURL) {
		fields = append(fields, project.FieldGithubRepoURL)
	}
	if m.FieldCleared(project.FieldGithubOwner) {
		fields = append(fields, project.FieldGithubOwner)
	}
	if m.FieldCleared(project.FieldGithubRepoName) {
		fields = append(fields, project.FieldGithubRepoName)
	}
	if m.FieldCleared(project.FieldGithubLastSync) {
		fields = append(fields, project.FieldGithubLastSync)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldTeamID:
		m.ClearTeamID()
		return nil
	case project.FieldDescription:
		m.ClearDescription()
		return nil
	case project.FieldGithubRepoURL:
		m.ClearGithubRepoURL()
		return nil
	case project.FieldGithubOwner:
		m.ClearGithubOwner()
		return nil
	case project.FieldGithubRepoName:
		m.ClearGithubRepoName()
		return nil
	case project.FieldGithubLastSync:
		m.ClearGithubLastSync()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case project.FieldTeamID:
		m.ResetTeamID()
		return nil
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldDescription:
		m.ResetDescription()
		return nil
	case project.FieldGithubRepoURL:
		m.ResetGithubRepoURL()
		return nil
	case project.FieldGithubOwner:
		m.ResetGithubOwner()
		return nil
	case project.FieldGithubRepoName:
		m.ResetGithubRepoName()
		return nil
	case project.FieldGithubBranch:
		m.ResetGithubBranch()
		return nil
	case project.FieldGithubSyncEnabled:
		m.ResetGithubSyncEnabled()
		return nil
	case project.FieldGithubLastSync:
		m.ResetGithubLastSync()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.owner != nil {
		edges = append(edges, project.EdgeOwner)
	}
	if m.team != nil {
		edges = append(edges, project.EdgeTeam)
	}
	if m.members != nil {
		edges = append(edges, project.EdgeMembers)
	}
	if m.tasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.swim_lanes != nil {
		edges = append(edges, project.EdgeSwimLanes)
	}
	if m.attachments != nil {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.wiki_pages != nil {
		edges = append(edges, project.EdgeWikiPages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSwimLanes:
		ids := make([]ent.Value, 0, len(m.swim_lanes))
		for id := range m.swim_lanes {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWikiPages:
		ids := make([]ent.Value, 0, len(m.wiki_pages))
		for id := range m.wiki_pages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedmembers != nil {
		edges = append(edges, project.EdgeMembers)
	}
	if m.removedtasks != nil {
		edges = append(edges, project.EdgeTasks)
	}
	if m.removedswim_lanes != nil {
		edges = append(edges, project.EdgeSwimLanes)
	}
	if m.removedattachments != nil {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.removedwiki_pages != nil {
		edges = append(edges, project.EdgeWikiPages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeSwimLanes:
		ids := make([]ent.Value, 0, len(m.removedswim_lanes))
		for id := range m.removedswim_lanes {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeWikiPages:
		ids := make([]ent.Value, 0, len(m.removedwiki_pages))
		for id := range m.removedwiki_pages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedowner {
		edges = append(edges, project.EdgeOwner)
	}
	if m.clearedteam {
		edges = append(edges, project.EdgeTeam)
	}
	if m.clearedmembers {
		edges = append(edges, project.EdgeMembers)
	}
	if m.clearedtasks {
		edges = append(edges, project.EdgeTasks)
	}
	if m.clearedswim_lanes {
		edges = append(edges, project.EdgeSwimLanes)
	}
	if m.clearedattachments {
		edges = append(edges, project.EdgeAttachments)
	}
	if m.clearedwiki_pages {
		edges = append(edges, project.EdgeWikiPages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeOwner:
		return m.clearedowner
	case project.EdgeTeam:
		return m.clearedteam
	case project.EdgeMembers:
		return m.clearedmembers
	case project.EdgeTasks:
		return m.clearedtasks
	case project.EdgeSwimLanes:
		return m.clearedswim_lanes
	case project.EdgeAttachments:
		return m.clearedattachments
	case project.EdgeWikiPages:
		return m.clearedwiki_pages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeOwner:
		m.ClearOwner()
		return nil
	case project.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeOwner:
		m.ResetOwner()
		return nil
	case project.EdgeTeam:
		m.ResetTeam()
		return nil
	case project.EdgeMembers:
		m.ResetMembers()
		return nil
	case project.EdgeTasks:
		m.ResetTasks()
		return nil
	case project.EdgeSwimLanes:
		m.ResetSwimLanes()
		return nil
	case project.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case project.EdgeWikiPages:
		m.ResetWikiPages()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectMemberMutation represents an operation that mutates the ProjectMember nodes in the graph.
type ProjectMemberMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	role           *string
	granted_at     *time.Time
	clearedFields  map[string]struct{}
	project        *int64
	clearedproject bool
	user           *int64
	cleareduser    bool
	granter        *int64
	clearedgranter bool
	done           bool
	oldValue       func(context.Context) (*ProjectMember, error)
	predicates     []predicate.ProjectMember
}

var _ ent.Mutation = (*ProjectMemberMutation)(nil)

// projectmemberOption allows management of the mutation configuration using functional options.
type projectmemberOption func(*ProjectMemberMutation)

// newProjectMemberMutation creates new mutation for the ProjectMember entity.
func newProjectMemberMutation(c config, op Op, opts ...projectmemberOption) *ProjectMemberMutation {
	m := &ProjectMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectMemberID sets the ID field of the mutation.
func withProjectMemberID(id int64) projectmemberOption {
	return func(m *ProjectMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectMember
		)
		m.oldValue = func(ctx context.Context) (*ProjectMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectMember sets the old ProjectMember of the mutation.
func withProjectMember(node *ProjectMember) projectmemberOption {
	return func(m *ProjectMemberMutation) {
		m.oldValue = func(context.Context) (*ProjectMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProjectMember entities.
func (m *ProjectMemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProjectMemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProjectMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *ProjectMemberMutation) SetProjectID(i int64) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectMemberMutation) ProjectID() (r int64, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectMemberMutation) ResetProjectID() {
	m.project = nil
}

// SetUserID sets the "user_id" field.
func (m *ProjectMemberMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ProjectMemberMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ProjectMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *ProjectMemberMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *ProjectMemberMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *ProjectMemberMutation) ResetRole() {
	m.role = nil
}

// SetGrantedBy sets the "granted_by" field.
func (m *ProjectMemberMutation) SetGrantedBy(i int64) {
	m.granter = &i
}

// GrantedBy returns the value of the "granted_by" field in the mutation.
func (m *ProjectMemberMutation) GrantedBy() (r int64, exists bool) {
	v := m.granter
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedBy returns the old "granted_by" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldGrantedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedBy: %w", err)
	}
	return oldValue.GrantedBy, nil
}

// ResetGrantedBy resets all changes to the "granted_by" field.
func (m *ProjectMemberMutation) ResetGrantedBy() {
	m.granter = nil
}

// SetGrantedAt sets the "granted_at" field.
func (m *ProjectMemberMutation) SetGrantedAt(t time.Time) {
	m.granted_at = &t
}

// GrantedAt returns the value of the "granted_at" field in the mutation.
func (m *ProjectMemberMutation) GrantedAt() (r time.Time, exists bool) {
	v := m.granted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldGrantedAt returns the old "granted_at" field's value of the ProjectMember entity.
// If the ProjectMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMemberMutation) OldGrantedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrantedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrantedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrantedAt: %w", err)
	}
	return oldValue.GrantedAt, nil
}

// ResetGrantedAt resets all changes to the "granted_at" field.
func (m *ProjectMemberMutation) ResetGrantedAt() {
	m.granted_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectMemberMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[projectmember.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectMemberMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectMemberMutation) ProjectIDs() (ids []int64) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectMemberMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProjectMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[projectmember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProjectMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProjectMemberMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProjectMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetGranterID sets the "granter" edge to the User entity by id.
func (m *ProjectMemberMutation) SetGranterID(id int64) {
	m.granter = &id
}

// ClearGranter clears the "granter" edge to the User entity.
func (m *ProjectMemberMutation) ClearGranter() {
	m.clearedgranter = true
	m.clearedFields[projectmember.FieldGrantedBy] = struct{}{}
}

// GranterCleared reports if the "granter" edge to the User entity was cleared.
func (m *ProjectMemberMutation) GranterCleared() bool {
	return m.clearedgranter
}

// GranterID returns the "granter" edge ID in the mutation.
func (m *ProjectMemberMutation) GranterID() (id int64, exists bool) {
	if m.granter != nil {
		return *m.granter, true
	}
	return
}

// GranterIDs returns the "granter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GranterID instead. It exists only for internal usage by the builders.
func (m *ProjectMemberMutation) GranterIDs() (ids []int64) {
	if id := m.granter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGranter resets all changes to the "granter" edge.
func (m *ProjectMemberMutation) ResetGranter() {
	m.granter = nil
	m.clearedgranter = false
}

// Where appends a list predicates to the ProjectMemberMutation builder.
func (m *ProjectMemberMutation) Where(ps ...predicate.ProjectMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProjectMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProjectMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProjectMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProjectMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProjectMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProjectMember).
func (m *ProjectMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.project != nil {
		fields = append(fields, projectmember.FieldProjectID)
	}
	if m.user != nil {
		fields = append(fields, projectmember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, projectmember.FieldRole)
	}
	if m.granter != nil {
		fields = append(fields, projectmember.FieldGrantedBy)
	}
	if m.granted_at != nil {
		fields = append(fields, projectmember.FieldGrantedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectmember.FieldProjectID:
		return m.ProjectID()
	case projectmember.FieldUserID:
		return m.UserID()
	case projectmember.FieldRole:
		return m.Role()
	case projectmember.FieldGrantedBy:
		return m.GrantedBy()
	case projectmember.FieldGrantedAt:
		return m.GrantedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectmember.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectmember.FieldUserID:
		return m.OldUserID(ctx)
	case projectmember.FieldRole:
		return m.OldRole(ctx)
	case projectmember.FieldGrantedBy:
		return m.OldGrantedBy(ctx)
	case projectmember.FieldGrantedAt:
		return m.OldGrantedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectmember.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectmember.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case projectmember.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case projectmember.FieldGrantedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedBy(v)
		return nil
	case projectmember.FieldGrantedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrantedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMemberMutation) ResetField(name string) error {
	switch name {
	case projectmember.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectmember.FieldUserID:
		m.ResetUserID()
		return nil
	case projectmember.FieldRole:
		m.ResetRole()
		return nil
	case projectmember.FieldGrantedBy:
		m.ResetGrantedBy()
		return nil
	case projectmember.FieldGrantedAt:
		m.ResetGrantedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.project != nil {
		edges = append(edges, projectmember.EdgeProject)
	}
	if m.user != nil {
		edges = append(edges, projectmember.EdgeUser)
	}
	if m.granter != nil {
		edges = append(edges, projectmember.EdgeGranter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectmember.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectmember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case projectmember.EdgeGranter:
		if id := m.granter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedproject {
		edges = append(edges, projectmember.EdgeProject)
	}
	if m.cleareduser {
		edges = append(edges, projectmember.EdgeUser)
	}
	if m.clearedgranter {
		edges = append(edges, projectmember.EdgeGranter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case projectmember.EdgeProject:
		return m.clearedproject
	case projectmember.EdgeUser:
		return m.cleareduser
	case projectmember.EdgeGranter:
		return m.clearedgranter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMemberMutation) ClearEdge(name string) error {
	switch name {
	case projectmember.EdgeProject:
		m.ClearProject()
		return nil
	case projectmember.EdgeUser:
		m.ClearUser()
		return nil
	case projectmember.EdgeGranter:
		m.ClearGranter()
		return nil
	}
	return fmt.Errorf("unknown ProjectMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMemberMutation) ResetEdge(name string) error {
	switch name {
	case projectmember.EdgeProject:
		m.ResetProject()
		return nil
	case projectmember.EdgeUser:
		m.ResetUser()
		return nil
	case projectmember.EdgeGranter:
		m.ResetGranter()
		return nil
	}
	return fmt.Errorf("unknown ProjectMember edge %s", name)
}

// SprintMutation represents an operation that mutates the Sprint nodes in the graph.
type SprintMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	name          *string
	goal          *string
	start_date    *time.Time
	end_date      *time.Time
	status        *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	team          *int64
	clearedteam   bool
	tasks         map[int64]struct{}
	removedtasks  map[int64]struct{}
	clearedtasks  bool
	done          bool
	oldValue      func(context.Context) (*Sprint, error)
	predicates    []predicate.Sprint
}

var _ ent.Mutation = (*SprintMutation)(nil)

// sprintOption allows management of the mutation configuration using functional options.
type sprintOption func(*SprintMutation)

// newSprintMutation creates new mutation for the Sprint entity.
func newSprintMutation(c config, op Op, opts ...sprintOption) *SprintMutation {
	m := &SprintMutation{
		config:        c,
		op:            op,
		typ:           TypeSprint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSprintID sets the ID field of the mutation.
func withSprintID(id int64) sprintOption {
	return func(m *SprintMutation) {
		var (
			err   error
			once  sync.Once
			value *Sprint
		)
		m.oldValue = func(ctx context.Context) (*Sprint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sprint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSprint sets the old Sprint of the mutation.
func withSprint(node *Sprint) sprintOption {
	return func(m *SprintMutation) {
		m.oldValue = func(context.Context) (*Sprint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SprintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SprintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sprint entities.
func (m *SprintMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SprintMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SprintMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sprint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *SprintMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SprintMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SprintMutation) ResetUserID() {
	m.user = nil
}

// SetTeamID sets the "team_id" field.
func (m *SprintMutation) SetTeamID(i int64) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *SprintMutation) TeamID() (r int64, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldTeamID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *SprintMutation) ClearTeamID() {
	m.team = nil
	m.clearedFields[sprint.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *SprintMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[sprint.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *SprintMutation) ResetTeamID() {
	m.team = nil
	delete(m.clearedFields, sprint.FieldTeamID)
}

// SetName sets the "name" field.
func (m *SprintMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SprintMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SprintMutation) ResetName() {
	m.name = nil
}

// SetGoal sets the "goal" field.
func (m *SprintMutation) SetGoal(s string) {
	m.goal = &s
}

// Goal returns the value of the "goal" field in the mutation.
func (m *SprintMutation) Goal() (r string, exists bool) {
	v := m.goal
	if v == nil {
		return
	}
	return *v, true
}

// OldGoal returns the old "goal" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldGoal(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoal: %w", err)
	}
	return oldValue.Goal, nil
}

// ClearGoal clears the value of the "goal" field.
func (m *SprintMutation) ClearGoal() {
	m.goal = nil
	m.clearedFields[sprint.FieldGoal] = struct{}{}
}

// GoalCleared returns if the "goal" field was cleared in this mutation.
func (m *SprintMutation) GoalCleared() bool {
	_, ok := m.clearedFields[sprint.FieldGoal]
	return ok
}

// ResetGoal resets all changes to the "goal" field.
func (m *SprintMutation) ResetGoal() {
	m.goal = nil
	delete(m.clearedFields, sprint.FieldGoal)
}

// SetStartDate sets the "start_date" field.
func (m *SprintMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *SprintMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldStartDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ClearStartDate clears the value of the "start_date" field.
func (m *SprintMutation) ClearStartDate() {
	m.start_date = nil
	m.clearedFields[sprint.FieldStartDate] = struct{}{}
}

// StartDateCleared returns if the "start_date" field was cleared in this mutation.
func (m *SprintMutation) StartDateCleared() bool {
	_, ok := m.clearedFields[sprint.FieldStartDate]
	return ok
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *SprintMutation) ResetStartDate() {
	m.start_date = nil
	delete(m.clearedFields, sprint.FieldStartDate)
}

// SetEndDate sets the "end_date" field.
func (m *SprintMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *SprintMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldEndDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *SprintMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[sprint.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *SprintMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[sprint.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *SprintMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, sprint.FieldEndDate)
}

// SetStatus sets the "status" field.
func (m *SprintMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SprintMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SprintMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SprintMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SprintMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SprintMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SprintMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SprintMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Sprint entity.
// If the Sprint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SprintMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SprintMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SprintMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[sprint.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SprintMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SprintMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SprintMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *SprintMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[sprint.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *SprintMutation) TeamCleared() bool {
	return m.TeamIDCleared() || m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *SprintMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *SprintMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *SprintMutation) AddTaskIDs(ids ...int64) {
	if m.tasks == nil {
		m.tasks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *SprintMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *SprintMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *SprintMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *SprintMutation) RemovedTasksIDs() (ids []int64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *SprintMutation) TasksIDs() (ids []int64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *SprintMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the SprintMutation builder.
func (m *SprintMutation) Where(ps ...predicate.Sprint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SprintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SprintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sprint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SprintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SprintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sprint).
func (m *SprintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SprintMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user != nil {
		fields = append(fields, sprint.FieldUserID)
	}
	if m.team != nil {
		fields = append(fields, sprint.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, sprint.FieldName)
	}
	if m.goal != nil {
		fields = append(fields, sprint.FieldGoal)
	}
	if m.start_date != nil {
		fields = append(fields, sprint.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, sprint.FieldEndDate)
	}
	if m.status != nil {
		fields = append(fields, sprint.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, sprint.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, sprint.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SprintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sprint.FieldUserID:
		return m.UserID()
	case sprint.FieldTeamID:
		return m.TeamID()
	case sprint.FieldName:
		return m.Name()
	case sprint.FieldGoal:
		return m.Goal()
	case sprint.FieldStartDate:
		return m.StartDate()
	case sprint.FieldEndDate:
		return m.EndDate()
	case sprint.FieldStatus:
		return m.Status()
	case sprint.FieldCreatedAt:
		return m.CreatedAt()
	case sprint.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SprintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sprint.FieldUserID:
		return m.OldUserID(ctx)
	case sprint.FieldTeamID:
		return m.OldTeamID(ctx)
	case sprint.FieldName:
		return m.OldName(ctx)
	case sprint.FieldGoal:
		return m.OldGoal(ctx)
	case sprint.FieldStartDate:
		return m.OldStartDate(ctx)
	case sprint.FieldEndDate:
		return m.OldEndDate(ctx)
	case sprint.FieldStatus:
		return m.OldStatus(ctx)
	case sprint.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case sprint.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Sprint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SprintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sprint.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case sprint.FieldTeamID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case sprint.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sprint.FieldGoal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoal(v)
		return nil
	case sprint.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case sprint.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case sprint.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case sprint.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case sprint.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Sprint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SprintMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SprintMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SprintMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sprint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SprintMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sprint.FieldTeamID) {
		fields = append(fields, sprint.FieldTeamID)
	}
	if m.FieldCleared(sprint.FieldGoal) {
		fields = append(fields, sprint.FieldGoal)
	}
	if m.FieldCleared(sprint.FieldStartDate) {
		fields = append(fields, sprint.FieldStartDate)
	}
	if m.FieldCleared(sprint.FieldEndDate) {
		fields = append(fields, sprint.FieldEndDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SprintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SprintMutation) ClearField(name string) error {
	switch name {
	case sprint.FieldTeamID:
		m.ClearTeamID()
		return nil
	case sprint.FieldGoal:
		m.ClearGoal()
		return nil
	case sprint.FieldStartDate:
		m.ClearStartDate()
		return nil
	case sprint.FieldEndDate:
		m.ClearEndDate()
		return nil
	}
	return fmt.Errorf("unknown Sprint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SprintMutation) ResetField(name string) error {
	switch name {
	case sprint.FieldUserID:
		m.ResetUserID()
		return nil
	case sprint.FieldTeamID:
		m.ResetTeamID()
		return nil
	case sprint.FieldName:
		m.ResetName()
		return nil
	case sprint.FieldGoal:
		m.ResetGoal()
		return nil
	case sprint.FieldStartDate:
		m.ResetStartDate()
		return nil
	case sprint.FieldEndDate:
		m.ResetEndDate()
		return nil
	case sprint.FieldStatus:
		m.ResetStatus()
		return nil
	case sprint.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case sprint.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Sprint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SprintMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, sprint.EdgeUser)
	}
	if m.team != nil {
		edges = append(edges, sprint.EdgeTeam)
	}
	if m.tasks != nil {
		edges = append(edges, sprint.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SprintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sprint.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case sprint.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case sprint.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SprintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtasks != nil {
		edges = append(edges, sprint.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SprintMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sprint.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SprintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, sprint.EdgeUser)
	}
	if m.clearedteam {
		edges = append(edges, sprint.EdgeTeam)
	}
	if m.clearedtasks {
		edges = append(edges, sprint.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SprintMutation) EdgeCleared(name string) bool {
	switch name {
	case sprint.EdgeUser:
		return m.cleareduser
	case sprint.EdgeTeam:
		return m.clearedteam
	case sprint.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SprintMutation) ClearEdge(name string) error {
	switch name {
	case sprint.EdgeUser:
		m.ClearUser()
		return nil
	case sprint.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Sprint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SprintMutation) ResetEdge(name string) error {
	switch name {
	case sprint.EdgeUser:
		m.ResetUser()
		return nil
	case sprint.EdgeTeam:
		m.ResetTeam()
		return nil
	case sprint.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown Sprint edge %s", name)
}

// SwimLaneMutation represents an operation that mutates the SwimLane nodes in the graph.
type SwimLaneMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	name            *string
	color           *string
	position        *int
	addposition     *int
	status_category *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	project         *int64
	clearedproject  bool
	tasks           map[int64]struct{}
	removedtasks    map[int64]struct{}
	clearedtasks    bool
	done            bool
	oldValue        func(context.Context) (*SwimLane, error)
	predicates      []predicate.SwimLane
}

var _ ent.Mutation = (*SwimLaneMutation)(nil)

// swimlaneOption allows management of the mutation configuration using functional options.
type swimlaneOption func(*SwimLaneMutation)

// newSwimLaneMutation creates new mutation for the SwimLane entity.
func newSwimLaneMutation(c config, op Op, opts ...swimlaneOption) *SwimLaneMutation {
	m := &SwimLaneMutation{
		config:        c,
		op:            op,
		typ:           TypeSwimLane,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSwimLaneID sets the ID field of the mutation.
func withSwimLaneID(id int64) swimlaneOption {
	return func(m *SwimLaneMutation) {
		var (
			err   error
			once  sync.Once
			value *SwimLane
		)
		m.oldValue = func(ctx context.Context) (*SwimLane, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SwimLane.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSwimLane sets the old SwimLane of the mutation.
func withSwimLane(node *SwimLane) swimlaneOption {
	return func(m *SwimLaneMutation) {
		m.oldValue = func(context.Context) (*SwimLane, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SwimLaneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SwimLaneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SwimLane entities.
func (m *SwimLaneMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SwimLaneMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SwimLaneMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SwimLane.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *SwimLaneMutation) SetProjectID(i int64) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *SwimLaneMutation) ProjectID() (r int64, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *SwimLaneMutation) ResetProjectID() {
	m.project = nil
}

// SetName sets the "name" field.
func (m *SwimLaneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SwimLaneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SwimLaneMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *SwimLaneMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *SwimLaneMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *SwimLaneMutation) ResetColor() {
	m.color = nil
}

// SetPosition sets the "position" field.
func (m *SwimLaneMutation) SetPosition(i int) {
	m.position = &i
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *SwimLaneMutation) Position() (r int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldPosition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// AddPosition adds i to the "position" field.
func (m *SwimLaneMutation) AddPosition(i int) {
	if m.addposition != nil {
		*m.addposition += i
	} else {
		m.addposition = &i
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *SwimLaneMutation) AddedPosition() (r int, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *SwimLaneMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// SetStatusCategory sets the "status_category" field.
func (m *SwimLaneMutation) SetStatusCategory(s string) {
	m.status_category = &s
}

// StatusCategory returns the value of the "status_category" field in the mutation.
func (m *SwimLaneMutation) StatusCategory() (r string, exists bool) {
	v := m.status_category
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusCategory returns the old "status_category" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldStatusCategory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusCategory: %w", err)
	}
	return oldValue.StatusCategory, nil
}

// ResetStatusCategory resets all changes to the "status_category" field.
func (m *SwimLaneMutation) ResetStatusCategory() {
	m.status_category = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SwimLaneMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SwimLaneMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SwimLaneMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SwimLaneMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SwimLaneMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SwimLane entity.
// If the SwimLane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwimLaneMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SwimLaneMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *SwimLaneMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[swimlane.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *SwimLaneMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *SwimLaneMutation) ProjectIDs() (ids []int64) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *SwimLaneMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddTaskIDs adds the "tasks" edge to the Task entity by ids.
func (m *SwimLaneMutation) AddTaskIDs(ids ...int64) {
	if m.tasks == nil {
		m.tasks = make(map[int64]struct{})
	}
	for i := range ids {
		m.tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "tasks" edge to the Task entity.
func (m *SwimLaneMutation) ClearTasks() {
	m.clearedtasks = true
}

// TasksCleared reports if the "tasks" edge to the Task entity was cleared.
func (m *SwimLaneMutation) TasksCleared() bool {
	return m.clearedtasks
}

// RemoveTaskIDs removes the "tasks" edge to the Task entity by IDs.
func (m *SwimLaneMutation) RemoveTaskIDs(ids ...int64) {
	if m.removedtasks == nil {
		m.removedtasks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tasks, ids[i])
		m.removedtasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "tasks" edge to the Task entity.
func (m *SwimLaneMutation) RemovedTasksIDs() (ids []int64) {
	for id := range m.removedtasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "tasks" edge IDs in the mutation.
func (m *SwimLaneMutation) TasksIDs() (ids []int64) {
	for id := range m.tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "tasks" edge.
func (m *SwimLaneMutation) ResetTasks() {
	m.tasks = nil
	m.clearedtasks = false
	m.removedtasks = nil
}

// Where appends a list predicates to the SwimLaneMutation builder.
func (m *SwimLaneMutation) Where(ps ...predicate.SwimLane) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SwimLaneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SwimLaneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SwimLane, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SwimLaneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SwimLaneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SwimLane).
func (m *SwimLaneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SwimLaneMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.project != nil {
		fields = append(fields, swimlane.FieldProjectID)
	}
	if m.name != nil {
		fields = append(fields, swimlane.FieldName)
	}
	if m.color != nil {
		fields = append(fields, swimlane.FieldColor)
	}
	if m.position != nil {
		fields = append(fields, swimlane.FieldPosition)
	}
	if m.status_category != nil {
		fields = append(fields, swimlane.FieldStatusCategory)
	}
	if m.created_at != nil {
		fields = append(fields, swimlane.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, swimlane.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SwimLaneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case swimlane.FieldProjectID:
		return m.ProjectID()
	case swimlane.FieldName:
		return m.Name()
	case swimlane.FieldColor:
		return m.Color()
	case swimlane.FieldPosition:
		return m.Position()
	case swimlane.FieldStatusCategory:
		return m.StatusCategory()
	case swimlane.FieldCreatedAt:
		return m.CreatedAt()
	case swimlane.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SwimLaneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case swimlane.FieldProjectID:
		return m.OldProjectID(ctx)
	case swimlane.FieldName:
		return m.OldName(ctx)
	case swimlane.FieldColor:
		return m.OldColor(ctx)
	case swimlane.FieldPosition:
		return m.OldPosition(ctx)
	case swimlane.FieldStatusCategory:
		return m.OldStatusCategory(ctx)
	case swimlane.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case swimlane.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SwimLane field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwimLaneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case swimlane.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case swimlane.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case swimlane.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case swimlane.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case swimlane.FieldStatusCategory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusCategory(v)
		return nil
	case swimlane.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case swimlane.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SwimLane field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SwimLaneMutation) AddedFields() []string {
	var fields []string
	if m.addposition != nil {
		fields = append(fields, swimlane.FieldPosition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SwimLaneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case swimlane.FieldPosition:
		return m.AddedPosition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwimLaneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case swimlane.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	}
	return fmt.Errorf("unknown SwimLane numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SwimLaneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SwimLaneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SwimLaneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SwimLane nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SwimLaneMutation) ResetField(name string) error {
	switch name {
	case swimlane.FieldProjectID:
		m.ResetProjectID()
		return nil
	case swimlane.FieldName:
		m.ResetName()
		return nil
	case swimlane.FieldColor:
		m.ResetColor()
		return nil
	case swimlane.FieldPosition:
		m.ResetPosition()
		return nil
	case swimlane.FieldStatusCategory:
		m.ResetStatusCategory()
		return nil
	case swimlane.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case swimlane.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown SwimLane field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SwimLaneMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.project != nil {
		edges = append(edges, swimlane.EdgeProject)
	}
	if m.tasks != nil {
		edges = append(edges, swimlane.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SwimLaneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case swimlane.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case swimlane.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.tasks))
		for id := range m.tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SwimLaneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtasks != nil {
		edges = append(edges, swimlane.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SwimLaneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case swimlane.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removedtasks))
		for id := range m.removedtasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SwimLaneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproject {
		edges = append(edges, swimlane.EdgeProject)
	}
	if m.clearedtasks {
		edges = append(edges, swimlane.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SwimLaneMutation) EdgeCleared(name string) bool {
	switch name {
	case swimlane.EdgeProject:
		return m.clearedproject
	case swimlane.EdgeTasks:
		return m.clearedtasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SwimLaneMutation) ClearEdge(name string) error {
	switch name {
	case swimlane.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown SwimLane unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SwimLaneMutation) ResetEdge(name string) error {
	switch name {
	case swimlane.EdgeProject:
		m.ResetProject()
		return nil
	case swimlane.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown SwimLane edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	name             *string
	color            *string
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	team             *int64
	clearedteam      bool
	task_tags        map[int]struct{}
	removedtask_tags map[int]struct{}
	clearedtask_tags bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *TagMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TagMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TagMutation) ResetUserID() {
	m.user = nil
}

// SetTeamID sets the "team_id" field.
func (m *TagMutation) SetTeamID(i int64) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TagMutation) TeamID() (r int64, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTeamID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ClearTeamID clears the value of the "team_id" field.
func (m *TagMutation) ClearTeamID() {
	m.team = nil
	m.clearedFields[tag.FieldTeamID] = struct{}{}
}

// TeamIDCleared returns if the "team_id" field was cleared in this mutation.
func (m *TagMutation) TeamIDCleared() bool {
	_, ok := m.clearedFields[tag.FieldTeamID]
	return ok
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TagMutation) ResetTeamID() {
	m.team = nil
	delete(m.clearedFields, tag.FieldTeamID)
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *TagMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[tag.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TagMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TagMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TagMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TagMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[tag.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TagMutation) TeamCleared() bool {
	return m.TeamIDCleared() || m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TagMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TagMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// AddTaskTagIDs adds the "task_tags" edge to the TaskTag entity by ids.
func (m *TagMutation) AddTaskTagIDs(ids ...int) {
	if m.task_tags == nil {
		m.task_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.task_tags[ids[i]] = struct{}{}
	}
}

// ClearTaskTags clears the "task_tags" edge to the TaskTag entity.
func (m *TagMutation) ClearTaskTags() {
	m.clearedtask_tags = true
}

// TaskTagsCleared reports if the "task_tags" edge to the TaskTag entity was cleared.
func (m *TagMutation) TaskTagsCleared() bool {
	return m.clearedtask_tags
}

// RemoveTaskTagIDs removes the "task_tags" edge to the TaskTag entity by IDs.
func (m *TagMutation) RemoveTaskTagIDs(ids ...int) {
	if m.removedtask_tags == nil {
		m.removedtask_tags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_tags, ids[i])
		m.removedtask_tags[ids[i]] = struct{}{}
	}
}

// RemovedTaskTags returns the removed IDs of the "task_tags" edge to the TaskTag entity.
func (m *TagMutation) RemovedTaskTagsIDs() (ids []int) {
	for id := range m.removedtask_tags {
		ids = append(ids, id)
	}
	return
}

// TaskTagsIDs returns the "task_tags" edge IDs in the mutation.
func (m *TagMutation) TaskTagsIDs() (ids []int) {
	for id := range m.task_tags {
		ids = append(ids, id)
	}
	return
}

// ResetTaskTags resets all changes to the "task_tags" edge.
func (m *TagMutation) ResetTaskTags() {
	m.task_tags = nil
	m.clearedtask_tags = false
	m.removedtask_tags = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, tag.FieldUserID)
	}
	if m.team != nil {
		fields = append(fields, tag.FieldTeamID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.created_at != nil {
		fields = append(fields, tag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldUserID:
		return m.UserID()
	case tag.FieldTeamID:
		return m.TeamID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldUserID:
		return m.OldUserID(ctx)
	case tag.FieldTeamID:
		return m.OldTeamID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case tag.FieldTeamID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldTeamID) {
		fields = append(fields, tag.FieldTeamID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldTeamID:
		m.ClearTeamID()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldUserID:
		m.ResetUserID()
		return nil
	case tag.FieldTeamID:
		m.ResetTeamID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, tag.EdgeUser)
	}
	if m.team != nil {
		edges = append(edges, tag.EdgeTeam)
	}
	if m.task_tags != nil {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.task_tags))
		for id := range m.task_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedtask_tags != nil {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.removedtask_tags))
		for id := range m.removedtask_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, tag.EdgeUser)
	}
	if m.clearedteam {
		edges = append(edges, tag.EdgeTeam)
	}
	if m.clearedtask_tags {
		edges = append(edges, tag.EdgeTaskTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeUser:
		return m.cleareduser
	case tag.EdgeTeam:
		return m.clearedteam
	case tag.EdgeTaskTags:
		return m.clearedtask_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeUser:
		m.ClearUser()
		return nil
	case tag.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeUser:
		m.ResetUser()
		return nil
	case tag.EdgeTeam:
		m.ResetTeam()
		return nil
	case tag.EdgeTaskTags:
		m.ResetTaskTags()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	task_number        *int
	addtask_number     *int
	title              *string
	description        *string
	status             *string
	priority           *string
	estimated_hours    *float64
	addestimated_hours *float64
	actual_hours       *float64
	addactual_hours    *float64
	due_date           *time.Time
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	project            *int64
	clearedproject     bool
	swim_lane          *int64
	clearedswim_lane   bool
	sprint             *int64
	clearedsprint      bool
	assignee           *int64
	clearedassignee    bool
	comments           map[int64]struct{}
	removedcomments    map[int64]struct{}
	clearedcomments    bool
	attachments        map[int64]struct{}
	removedattachments map[int64]struct{}
	clearedattachments bool
	task_tags          map[int]struct{}
	removedtask_tags   map[int]struct{}
	clearedtask_tags   bool
	done               bool
	oldValue           func(context.Context) (*Task, error)
	predicates         []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id int64) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *TaskMutation) SetProjectID(i int64) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TaskMutation) ProjectID() (r int64, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TaskMutation) ResetProjectID() {
	m.project = nil
}

// SetTaskNumber sets the "task_number" field.
func (m *TaskMutation) SetTaskNumber(i int) {
	m.task_number = &i
	m.addtask_number = nil
}

// TaskNumber returns the value of the "task_number" field in the mutation.
func (m *TaskMutation) TaskNumber() (r int, exists bool) {
	v := m.task_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskNumber returns the old "task_number" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTaskNumber(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskNumber: %w", err)
	}
	return oldValue.TaskNumber, nil
}

// AddTaskNumber adds i to the "task_number" field.
func (m *TaskMutation) AddTaskNumber(i int) {
	if m.addtask_number != nil {
		*m.addtask_number += i
	} else {
		m.addtask_number = &i
	}
}

// AddedTaskNumber returns the value that was added to the "task_number" field in this mutation.
func (m *TaskMutation) AddedTaskNumber() (r int, exists bool) {
	v := m.addtask_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearTaskNumber clears the value of the "task_number" field.
func (m *TaskMutation) ClearTaskNumber() {
	m.task_number = nil
	m.addtask_number = nil
	m.clearedFields[task.FieldTaskNumber] = struct{}{}
}

// TaskNumberCleared returns if the "task_number" field was cleared in this mutation.
func (m *TaskMutation) TaskNumberCleared() bool {
	_, ok := m.clearedFields[task.FieldTaskNumber]
	return ok
}

// ResetTaskNumber resets all changes to the "task_number" field.
func (m *TaskMutation) ResetTaskNumber() {
	m.task_number = nil
	m.addtask_number = nil
	delete(m.clearedFields, task.FieldTaskNumber)
}

// SetTitle sets the "title" field.
func (m *TaskMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TaskMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TaskMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TaskMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[task.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TaskMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[task.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TaskMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, task.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
}

// SetSwimLaneID sets the "swim_lane_id" field.
func (m *TaskMutation) SetSwimLaneID(i int64) {
	m.swim_lane = &i
}

// SwimLaneID returns the value of the "swim_lane_id" field in the mutation.
func (m *TaskMutation) SwimLaneID() (r int64, exists bool) {
	v := m.swim_lane
	if v == nil {
		return
	}
	return *v, true
}

// OldSwimLaneID returns the old "swim_lane_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSwimLaneID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSwimLaneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSwimLaneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSwimLaneID: %w", err)
	}
	return oldValue.SwimLaneID, nil
}

// ClearSwimLaneID clears the value of the "swim_lane_id" field.
func (m *TaskMutation) ClearSwimLaneID() {
	m.swim_lane = nil
	m.clearedFields[task.FieldSwimLaneID] = struct{}{}
}

// SwimLaneIDCleared returns if the "swim_lane_id" field was cleared in this mutation.
func (m *TaskMutation) SwimLaneIDCleared() bool {
	_, ok := m.clearedFields[task.FieldSwimLaneID]
	return ok
}

// ResetSwimLaneID resets all changes to the "swim_lane_id" field.
func (m *TaskMutation) ResetSwimLaneID() {
	m.swim_lane = nil
	delete(m.clearedFields, task.FieldSwimLaneID)
}

// SetSprintID sets the "sprint_id" field.
func (m *TaskMutation) SetSprintID(i int64) {
	m.sprint = &i
}

// SprintID returns the value of the "sprint_id" field in the mutation.
func (m *TaskMutation) SprintID() (r int64, exists bool) {
	v := m.sprint
	if v == nil {
		return
	}
	return *v, true
}

// OldSprintID returns the old "sprint_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldSprintID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSprintID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSprintID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSprintID: %w", err)
	}
	return oldValue.SprintID, nil
}

// ClearSprintID clears the value of the "sprint_id" field.
func (m *TaskMutation) ClearSprintID() {
	m.sprint = nil
	m.clearedFields[task.FieldSprintID] = struct{}{}
}

// SprintIDCleared returns if the "sprint_id" field was cleared in this mutation.
func (m *TaskMutation) SprintIDCleared() bool {
	_, ok := m.clearedFields[task.FieldSprintID]
	return ok
}

// ResetSprintID resets all changes to the "sprint_id" field.
func (m *TaskMutation) ResetSprintID() {
	m.sprint = nil
	delete(m.clearedFields, task.FieldSprintID)
}

// SetAssigneeID sets the "assignee_id" field.
func (m *TaskMutation) SetAssigneeID(i int64) {
	m.assignee = &i
}

// AssigneeID returns the value of the "assignee_id" field in the mutation.
func (m *TaskMutation) AssigneeID() (r int64, exists bool) {
	v := m.assignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAssigneeID returns the old "assignee_id" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldAssigneeID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssigneeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssigneeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssigneeID: %w", err)
	}
	return oldValue.AssigneeID, nil
}

// ClearAssigneeID clears the value of the "assignee_id" field.
func (m *TaskMutation) ClearAssigneeID() {
	m.assignee = nil
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeIDCleared returns if the "assignee_id" field was cleared in this mutation.
func (m *TaskMutation) AssigneeIDCleared() bool {
	_, ok := m.clearedFields[task.FieldAssigneeID]
	return ok
}

// ResetAssigneeID resets all changes to the "assignee_id" field.
func (m *TaskMutation) ResetAssigneeID() {
	m.assignee = nil
	delete(m.clearedFields, task.FieldAssigneeID)
}

// SetPriority sets the "priority" field.
func (m *TaskMutation) SetPriority(s string) {
	m.priority = &s
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TaskMutation) Priority() (r string, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldPriority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// ResetPriority resets all changes to the "priority" field.
func (m *TaskMutation) ResetPriority() {
	m.priority = nil
}

// SetEstimatedHours sets the "estimated_hours" field.
func (m *TaskMutation) SetEstimatedHours(f float64) {
	m.estimated_hours = &f
	m.addestimated_hours = nil
}

// EstimatedHours returns the value of the "estimated_hours" field in the mutation.
func (m *TaskMutation) EstimatedHours() (r float64, exists bool) {
	v := m.estimated_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatedHours returns the old "estimated_hours" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldEstimatedHours(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatedHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatedHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatedHours: %w", err)
	}
	return oldValue.EstimatedHours, nil
}

// AddEstimatedHours adds f to the "estimated_hours" field.
func (m *TaskMutation) AddEstimatedHours(f float64) {
	if m.addestimated_hours != nil {
		*m.addestimated_hours += f
	} else {
		m.addestimated_hours = &f
	}
}

// AddedEstimatedHours returns the value that was added to the "estimated_hours" field in this mutation.
func (m *TaskMutation) AddedEstimatedHours() (r float64, exists bool) {
	v := m.addestimated_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatedHours clears the value of the "estimated_hours" field.
func (m *TaskMutation) ClearEstimatedHours() {
	m.estimated_hours = nil
	m.addestimated_hours = nil
	m.clearedFields[task.FieldEstimatedHours] = struct{}{}
}

// EstimatedHoursCleared returns if the "estimated_hours" field was cleared in this mutation.
func (m *TaskMutation) EstimatedHoursCleared() bool {
	_, ok := m.clearedFields[task.FieldEstimatedHours]
	return ok
}

// ResetEstimatedHours resets all changes to the "estimated_hours" field.
func (m *TaskMutation) ResetEstimatedHours() {
	m.estimated_hours = nil
	m.addestimated_hours = nil
	delete(m.clearedFields, task.FieldEstimatedHours)
}

// SetActualHours sets the "actual_hours" field.
func (m *TaskMutation) SetActualHours(f float64) {
	m.actual_hours = &f
	m.addactual_hours = nil
}

// ActualHours returns the value of the "actual_hours" field in the mutation.
func (m *TaskMutation) ActualHours() (r float64, exists bool) {
	v := m.actual_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldActualHours returns the old "actual_hours" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldActualHours(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualHours: %w", err)
	}
	return oldValue.ActualHours, nil
}

// AddActualHours adds f to the "actual_hours" field.
func (m *TaskMutation) AddActualHours(f float64) {
	if m.addactual_hours != nil {
		*m.addactual_hours += f
	} else {
		m.addactual_hours = &f
	}
}

// AddedActualHours returns the value that was added to the "actual_hours" field in this mutation.
func (m *TaskMutation) AddedActualHours() (r float64, exists bool) {
	v := m.addactual_hours
	if v == nil {
		return
	}
	return *v, true
}

// ClearActualHours clears the value of the "actual_hours" field.
func (m *TaskMutation) ClearActualHours() {
	m.actual_hours = nil
	m.addactual_hours = nil
	m.clearedFields[task.FieldActualHours] = struct{}{}
}

// ActualHoursCleared returns if the "actual_hours" field was cleared in this mutation.
func (m *TaskMutation) ActualHoursCleared() bool {
	_, ok := m.clearedFields[task.FieldActualHours]
	return ok
}

// ResetActualHours resets all changes to the "actual_hours" field.
func (m *TaskMutation) ResetActualHours() {
	m.actual_hours = nil
	m.addactual_hours = nil
	delete(m.clearedFields, task.FieldActualHours)
}

// SetDueDate sets the "due_date" field.
func (m *TaskMutation) SetDueDate(t time.Time) {
	m.due_date = &t
}

// DueDate returns the value of the "due_date" field in the mutation.
func (m *TaskMutation) DueDate() (r time.Time, exists bool) {
	v := m.due_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDueDate returns the old "due_date" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldDueDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDueDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDueDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDueDate: %w", err)
	}
	return oldValue.DueDate, nil
}

// ClearDueDate clears the value of the "due_date" field.
func (m *TaskMutation) ClearDueDate() {
	m.due_date = nil
	m.clearedFields[task.FieldDueDate] = struct{}{}
}

// DueDateCleared returns if the "due_date" field was cleared in this mutation.
func (m *TaskMutation) DueDateCleared() bool {
	_, ok := m.clearedFields[task.FieldDueDate]
	return ok
}

// ResetDueDate resets all changes to the "due_date" field.
func (m *TaskMutation) ResetDueDate() {
	m.due_date = nil
	delete(m.clearedFields, task.FieldDueDate)
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TaskMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[task.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TaskMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) ProjectIDs() (ids []int64) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TaskMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearSwimLane clears the "swim_lane" edge to the SwimLane entity.
func (m *TaskMutation) ClearSwimLane() {
	m.clearedswim_lane = true
	m.clearedFields[task.FieldSwimLaneID] = struct{}{}
}

// SwimLaneCleared reports if the "swim_lane" edge to the SwimLane entity was cleared.
func (m *TaskMutation) SwimLaneCleared() bool {
	return m.SwimLaneIDCleared() || m.clearedswim_lane
}

// SwimLaneIDs returns the "swim_lane" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SwimLaneID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) SwimLaneIDs() (ids []int64) {
	if id := m.swim_lane; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSwimLane resets all changes to the "swim_lane" edge.
func (m *TaskMutation) ResetSwimLane() {
	m.swim_lane = nil
	m.clearedswim_lane = false
}

// ClearSprint clears the "sprint" edge to the Sprint entity.
func (m *TaskMutation) ClearSprint() {
	m.clearedsprint = true
	m.clearedFields[task.FieldSprintID] = struct{}{}
}

// SprintCleared reports if the "sprint" edge to the Sprint entity was cleared.
func (m *TaskMutation) SprintCleared() bool {
	return m.SprintIDCleared() || m.clearedsprint
}

// SprintIDs returns the "sprint" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SprintID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) SprintIDs() (ids []int64) {
	if id := m.sprint; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSprint resets all changes to the "sprint" edge.
func (m *TaskMutation) ResetSprint() {
	m.sprint = nil
	m.clearedsprint = false
}

// ClearAssignee clears the "assignee" edge to the User entity.
func (m *TaskMutation) ClearAssignee() {
	m.clearedassignee = true
	m.clearedFields[task.FieldAssigneeID] = struct{}{}
}

// AssigneeCleared reports if the "assignee" edge to the User entity was cleared.
func (m *TaskMutation) AssigneeCleared() bool {
	return m.AssigneeIDCleared() || m.clearedassignee
}

// AssigneeIDs returns the "assignee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssigneeID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) AssigneeIDs() (ids []int64) {
	if id := m.assignee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignee resets all changes to the "assignee" edge.
func (m *TaskMutation) ResetAssignee() {
	m.assignee = nil
	m.clearedassignee = false
}

// AddCommentIDs adds the "comments" edge to the TaskComment entity by ids.
func (m *TaskMutation) AddCommentIDs(ids ...int64) {
	if m.comments == nil {
		m.comments = make(map[int64]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the TaskComment entity.
func (m *TaskMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the TaskComment entity was cleared.
func (m *TaskMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the TaskComment entity by IDs.
func (m *TaskMutation) RemoveCommentIDs(ids ...int64) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the TaskComment entity.
func (m *TaskMutation) RemovedCommentsIDs() (ids []int64) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *TaskMutation) CommentsIDs() (ids []int64) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *TaskMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddAttachmentIDs adds the "attachments" edge to the TaskAttachment entity by ids.
func (m *TaskMutation) AddAttachmentIDs(ids ...int64) {
	if m.attachments == nil {
		m.attachments = make(map[int64]struct{})
	}
	for i := range ids {
		m.attachments[ids[i]] = struct{}{}
	}
}

// ClearAttachments clears the "attachments" edge to the TaskAttachment entity.
func (m *TaskMutation) ClearAttachments() {
	m.clearedattachments = true
}

// AttachmentsCleared reports if the "attachments" edge to the TaskAttachment entity was cleared.
func (m *TaskMutation) AttachmentsCleared() bool {
	return m.clearedattachments
}

// RemoveAttachmentIDs removes the "attachments" edge to the TaskAttachment entity by IDs.
func (m *TaskMutation) RemoveAttachmentIDs(ids ...int64) {
	if m.removedattachments == nil {
		m.removedattachments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attachments, ids[i])
		m.removedattachments[ids[i]] = struct{}{}
	}
}

// RemovedAttachments returns the removed IDs of the "attachments" edge to the TaskAttachment entity.
func (m *TaskMutation) RemovedAttachmentsIDs() (ids []int64) {
	for id := range m.removedattachments {
		ids = append(ids, id)
	}
	return
}

// AttachmentsIDs returns the "attachments" edge IDs in the mutation.
func (m *TaskMutation) AttachmentsIDs() (ids []int64) {
	for id := range m.attachments {
		ids = append(ids, id)
	}
	return
}

// ResetAttachments resets all changes to the "attachments" edge.
func (m *TaskMutation) ResetAttachments() {
	m.attachments = nil
	m.clearedattachments = false
	m.removedattachments = nil
}

// AddTaskTagIDs adds the "task_tags" edge to the TaskTag entity by ids.
func (m *TaskMutation) AddTaskTagIDs(ids ...int) {
	if m.task_tags == nil {
		m.task_tags = make(map[int]struct{})
	}
	for i := range ids {
		m.task_tags[ids[i]] = struct{}{}
	}
}

// ClearTaskTags clears the "task_tags" edge to the TaskTag entity.
func (m *TaskMutation) ClearTaskTags() {
	m.clearedtask_tags = true
}

// TaskTagsCleared reports if the "task_tags" edge to the TaskTag entity was cleared.
func (m *TaskMutation) TaskTagsCleared() bool {
	return m.clearedtask_tags
}

// RemoveTaskTagIDs removes the "task_tags" edge to the TaskTag entity by IDs.
func (m *TaskMutation) RemoveTaskTagIDs(ids ...int) {
	if m.removedtask_tags == nil {
		m.removedtask_tags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_tags, ids[i])
		m.removedtask_tags[ids[i]] = struct{}{}
	}
}

// RemovedTaskTags returns the removed IDs of the "task_tags" edge to the TaskTag entity.
func (m *TaskMutation) RemovedTaskTagsIDs() (ids []int) {
	for id := range m.removedtask_tags {
		ids = append(ids, id)
	}
	return
}

// TaskTagsIDs returns the "task_tags" edge IDs in the mutation.
func (m *TaskMutation) TaskTagsIDs() (ids []int) {
	for id := range m.task_tags {
		ids = append(ids, id)
	}
	return
}

// ResetTaskTags resets all changes to the "task_tags" edge.
func (m *TaskMutation) ResetTaskTags() {
	m.task_tags = nil
	m.clearedtask_tags = false
	m.removedtask_tags = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Task, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.project != nil {
		fields = append(fields, task.FieldProjectID)
	}
	if m.task_number != nil {
		fields = append(fields, task.FieldTaskNumber)
	}
	if m.title != nil {
		fields = append(fields, task.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, task.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.swim_lane != nil {
		fields = append(fields, task.FieldSwimLaneID)
	}
	if m.sprint != nil {
		fields = append(fields, task.FieldSprintID)
	}
	if m.assignee != nil {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.priority != nil {
		fields = append(fields, task.FieldPriority)
	}
	if m.estimated_hours != nil {
		fields = append(fields, task.FieldEstimatedHours)
	}
	if m.actual_hours != nil {
		fields = append(fields, task.FieldActualHours)
	}
	if m.due_date != nil {
		fields = append(fields, task.FieldDueDate)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldProjectID:
		return m.ProjectID()
	case task.FieldTaskNumber:
		return m.TaskNumber()
	case task.FieldTitle:
		return m.Title()
	case task.FieldDescription:
		return m.Description()
	case task.FieldStatus:
		return m.Status()
	case task.FieldSwimLaneID:
		return m.SwimLaneID()
	case task.FieldSprintID:
		return m.SprintID()
	case task.FieldAssigneeID:
		return m.AssigneeID()
	case task.FieldPriority:
		return m.Priority()
	case task.FieldEstimatedHours:
		return m.EstimatedHours()
	case task.FieldActualHours:
		return m.ActualHours()
	case task.FieldDueDate:
		return m.DueDate()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldProjectID:
		return m.OldProjectID(ctx)
	case task.FieldTaskNumber:
		return m.OldTaskNumber(ctx)
	case task.FieldTitle:
		return m.OldTitle(ctx)
	case task.FieldDescription:
		return m.OldDescription(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldSwimLaneID:
		return m.OldSwimLaneID(ctx)
	case task.FieldSprintID:
		return m.OldSprintID(ctx)
	case task.FieldAssigneeID:
		return m.OldAssigneeID(ctx)
	case task.FieldPriority:
		return m.OldPriority(ctx)
	case task.FieldEstimatedHours:
		return m.OldEstimatedHours(ctx)
	case task.FieldActualHours:
		return m.OldActualHours(ctx)
	case task.FieldDueDate:
		return m.OldDueDate(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case task.FieldTaskNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskNumber(v)
		return nil
	case task.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case task.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldSwimLaneID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSwimLaneID(v)
		return nil
	case task.FieldSprintID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSprintID(v)
		return nil
	case task.FieldAssigneeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssigneeID(v)
		return nil
	case task.FieldPriority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case task.FieldEstimatedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatedHours(v)
		return nil
	case task.FieldActualHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualHours(v)
		return nil
	case task.FieldDueDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDueDate(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	var fields []string
	if m.addtask_number != nil {
		fields = append(fields, task.FieldTaskNumber)
	}
	if m.addestimated_hours != nil {
		fields = append(fields, task.FieldEstimatedHours)
	}
	if m.addactual_hours != nil {
		fields = append(fields, task.FieldActualHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case task.FieldTaskNumber:
		return m.AddedTaskNumber()
	case task.FieldEstimatedHours:
		return m.AddedEstimatedHours()
	case task.FieldActualHours:
		return m.AddedActualHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case task.FieldTaskNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskNumber(v)
		return nil
	case task.FieldEstimatedHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatedHours(v)
		return nil
	case task.FieldActualHours:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualHours(v)
		return nil
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldTaskNumber) {
		fields = append(fields, task.FieldTaskNumber)
	}
	if m.FieldCleared(task.FieldDescription) {
		fields = append(fields, task.FieldDescription)
	}
	if m.FieldCleared(task.FieldSwimLaneID) {
		fields = append(fields, task.FieldSwimLaneID)
	}
	if m.FieldCleared(task.FieldSprintID) {
		fields = append(fields, task.FieldSprintID)
	}
	if m.FieldCleared(task.FieldAssigneeID) {
		fields = append(fields, task.FieldAssigneeID)
	}
	if m.FieldCleared(task.FieldEstimatedHours) {
		fields = append(fields, task.FieldEstimatedHours)
	}
	if m.FieldCleared(task.FieldActualHours) {
		fields = append(fields, task.FieldActualHours)
	}
	if m.FieldCleared(task.FieldDueDate) {
		fields = append(fields, task.FieldDueDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldTaskNumber:
		m.ClearTaskNumber()
		return nil
	case task.FieldDescription:
		m.ClearDescription()
		return nil
	case task.FieldSwimLaneID:
		m.ClearSwimLaneID()
		return nil
	case task.FieldSprintID:
		m.ClearSprintID()
		return nil
	case task.FieldAssigneeID:
		m.ClearAssigneeID()
		return nil
	case task.FieldEstimatedHours:
		m.ClearEstimatedHours()
		return nil
	case task.FieldActualHours:
		m.ClearActualHours()
		return nil
	case task.FieldDueDate:
		m.ClearDueDate()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldProjectID:
		m.ResetProjectID()
		return nil
	case task.FieldTaskNumber:
		m.ResetTaskNumber()
		return nil
	case task.FieldTitle:
		m.ResetTitle()
		return nil
	case task.FieldDescription:
		m.ResetDescription()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldSwimLaneID:
		m.ResetSwimLaneID()
		return nil
	case task.FieldSprintID:
		m.ResetSprintID()
		return nil
	case task.FieldAssigneeID:
		m.ResetAssigneeID()
		return nil
	case task.FieldPriority:
		m.ResetPriority()
		return nil
	case task.FieldEstimatedHours:
		m.ResetEstimatedHours()
		return nil
	case task.FieldActualHours:
		m.ResetActualHours()
		return nil
	case task.FieldDueDate:
		m.ResetDueDate()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.project != nil {
		edges = append(edges, task.EdgeProject)
	}
	if m.swim_lane != nil {
		edges = append(edges, task.EdgeSwimLane)
	}
	if m.sprint != nil {
		edges = append(edges, task.EdgeSprint)
	}
	if m.assignee != nil {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.comments != nil {
		edges = append(edges, task.EdgeComments)
	}
	if m.attachments != nil {
		edges = append(edges, task.EdgeAttachments)
	}
	if m.task_tags != nil {
		edges = append(edges, task.EdgeTaskTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeSwimLane:
		if id := m.swim_lane; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeSprint:
		if id := m.sprint; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeAssignee:
		if id := m.assignee; id != nil {
			return []ent.Value{*id}
		}
	case task.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.attachments))
		for id := range m.attachments {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.task_tags))
		for id := range m.task_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedcomments != nil {
		edges = append(edges, task.EdgeComments)
	}
	if m.removedattachments != nil {
		edges = append(edges, task.EdgeAttachments)
	}
	if m.removedtask_tags != nil {
		edges = append(edges, task.EdgeTaskTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeAttachments:
		ids := make([]ent.Value, 0, len(m.removedattachments))
		for id := range m.removedattachments {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskTags:
		ids := make([]ent.Value, 0, len(m.removedtask_tags))
		for id := range m.removedtask_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedproject {
		edges = append(edges, task.EdgeProject)
	}
	if m.clearedswim_lane {
		edges = append(edges, task.EdgeSwimLane)
	}
	if m.clearedsprint {
		edges = append(edges, task.EdgeSprint)
	}
	if m.clearedassignee {
		edges = append(edges, task.EdgeAssignee)
	}
	if m.clearedcomments {
		edges = append(edges, task.EdgeComments)
	}
	if m.clearedattachments {
		edges = append(edges, task.EdgeAttachments)
	}
	if m.clearedtask_tags {
		edges = append(edges, task.EdgeTaskTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeProject:
		return m.clearedproject
	case task.EdgeSwimLane:
		return m.clearedswim_lane
	case task.EdgeSprint:
		return m.clearedsprint
	case task.EdgeAssignee:
		return m.clearedassignee
	case task.EdgeComments:
		return m.clearedcomments
	case task.EdgeAttachments:
		return m.clearedattachments
	case task.EdgeTaskTags:
		return m.clearedtask_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeProject:
		m.ClearProject()
		return nil
	case task.EdgeSwimLane:
		m.ClearSwimLane()
		return nil
	case task.EdgeSprint:
		m.ClearSprint()
		return nil
	case task.EdgeAssignee:
		m.ClearAssignee()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeProject:
		m.ResetProject()
		return nil
	case task.EdgeSwimLane:
		m.ResetSwimLane()
		return nil
	case task.EdgeSprint:
		m.ResetSprint()
		return nil
	case task.EdgeAssignee:
		m.ResetAssignee()
		return nil
	case task.EdgeComments:
		m.ResetComments()
		return nil
	case task.EdgeAttachments:
		m.ResetAttachments()
		return nil
	case task.EdgeTaskTags:
		m.ResetTaskTags()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskAttachmentMutation represents an operation that mutates the TaskAttachment nodes in the graph.
type TaskAttachmentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	filename             *string
	file_type            *string
	content_type         *string
	file_size            *int
	addfile_size         *int
	cloudinary_url       *string
	cloudinary_public_id *string
	alt_name             *string
	created_at           *time.Time
	clearedFields        map[string]struct{}
	task                 *int64
	clearedtask          bool
	project              *int64
	clearedproject       bool
	user                 *int64
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*TaskAttachment, error)
	predicates           []predicate.TaskAttachment
}

var _ ent.Mutation = (*TaskAttachmentMutation)(nil)

// taskattachmentOption allows management of the mutation configuration using functional options.
type taskattachmentOption func(*TaskAttachmentMutation)

// newTaskAttachmentMutation creates new mutation for the TaskAttachment entity.
func newTaskAttachmentMutation(c config, op Op, opts ...taskattachmentOption) *TaskAttachmentMutation {
	m := &TaskAttachmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskAttachment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskAttachmentID sets the ID field of the mutation.
func withTaskAttachmentID(id int64) taskattachmentOption {
	return func(m *TaskAttachmentMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskAttachment
		)
		m.oldValue = func(ctx context.Context) (*TaskAttachment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskAttachment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskAttachment sets the old TaskAttachment of the mutation.
func withTaskAttachment(node *TaskAttachment) taskattachmentOption {
	return func(m *TaskAttachmentMutation) {
		m.oldValue = func(context.Context) (*TaskAttachment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskAttachmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskAttachmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskAttachment entities.
func (m *TaskAttachmentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskAttachmentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskAttachmentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskAttachment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskAttachmentMutation) SetTaskID(i int64) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskAttachmentMutation) TaskID() (r int64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskAttachmentMutation) ResetTaskID() {
	m.task = nil
}

// SetProjectID sets the "project_id" field.
func (m *TaskAttachmentMutation) SetProjectID(i int64) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *TaskAttachmentMutation) ProjectID() (r int64, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *TaskAttachmentMutation) ResetProjectID() {
	m.project = nil
}

// SetUserID sets the "user_id" field.
func (m *TaskAttachmentMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TaskAttachmentMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TaskAttachmentMutation) ResetUserID() {
	m.user = nil
}

// SetFilename sets the "filename" field.
func (m *TaskAttachmentMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *TaskAttachmentMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *TaskAttachmentMutation) ResetFilename() {
	m.filename = nil
}

// SetFileType sets the "file_type" field.
func (m *TaskAttachmentMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *TaskAttachmentMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ResetFileType resets all changes to the "file_type" field.
func (m *TaskAttachmentMutation) ResetFileType() {
	m.file_type = nil
}

// SetContentType sets the "content_type" field.
func (m *TaskAttachmentMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *TaskAttachmentMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldContentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ResetContentType resets all changes to the "content_type" field.
func (m *TaskAttachmentMutation) ResetContentType() {
	m.content_type = nil
}

// SetFileSize sets the "file_size" field.
func (m *TaskAttachmentMutation) SetFileSize(i int) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *TaskAttachmentMutation) FileSize() (r int, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldFileSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *TaskAttachmentMutation) AddFileSize(i int) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *TaskAttachmentMutation) AddedFileSize() (r int, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *TaskAttachmentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetCloudinaryURL sets the "cloudinary_url" field.
func (m *TaskAttachmentMutation) SetCloudinaryURL(s string) {
	m.cloudinary_url = &s
}

// CloudinaryURL returns the value of the "cloudinary_url" field in the mutation.
func (m *TaskAttachmentMutation) CloudinaryURL() (r string, exists bool) {
	v := m.cloudinary_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudinaryURL returns the old "cloudinary_url" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldCloudinaryURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudinaryURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudinaryURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudinaryURL: %w", err)
	}
	return oldValue.CloudinaryURL, nil
}

// ResetCloudinaryURL resets all changes to the "cloudinary_url" field.
func (m *TaskAttachmentMutation) ResetCloudinaryURL() {
	m.cloudinary_url = nil
}

// SetCloudinaryPublicID sets the "cloudinary_public_id" field.
func (m *TaskAttachmentMutation) SetCloudinaryPublicID(s string) {
	m.cloudinary_public_id = &s
}

// CloudinaryPublicID returns the value of the "cloudinary_public_id" field in the mutation.
func (m *TaskAttachmentMutation) CloudinaryPublicID() (r string, exists bool) {
	v := m.cloudinary_public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCloudinaryPublicID returns the old "cloudinary_public_id" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldCloudinaryPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloudinaryPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloudinaryPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloudinaryPublicID: %w", err)
	}
	return oldValue.CloudinaryPublicID, nil
}

// ResetCloudinaryPublicID resets all changes to the "cloudinary_public_id" field.
func (m *TaskAttachmentMutation) ResetCloudinaryPublicID() {
	m.cloudinary_public_id = nil
}

// SetAltName sets the "alt_name" field.
func (m *TaskAttachmentMutation) SetAltName(s string) {
	m.alt_name = &s
}

// AltName returns the value of the "alt_name" field in the mutation.
func (m *TaskAttachmentMutation) AltName() (r string, exists bool) {
	v := m.alt_name
	if v == nil {
		return
	}
	return *v, true
}

// OldAltName returns the old "alt_name" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldAltName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAltName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAltName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAltName: %w", err)
	}
	return oldValue.AltName, nil
}

// ResetAltName resets all changes to the "alt_name" field.
func (m *TaskAttachmentMutation) ResetAltName() {
	m.alt_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskAttachmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskAttachmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskAttachment entity.
// If the TaskAttachment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskAttachmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskAttachmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskAttachmentMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[taskattachment.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskAttachmentMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskAttachmentMutation) TaskIDs() (ids []int64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskAttachmentMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TaskAttachmentMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[taskattachment.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TaskAttachmentMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TaskAttachmentMutation) ProjectIDs() (ids []int64) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TaskAttachmentMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TaskAttachmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[taskattachment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TaskAttachmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TaskAttachmentMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TaskAttachmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TaskAttachmentMutation builder.
func (m *TaskAttachmentMutation) Where(ps ...predicate.TaskAttachment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskAttachmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskAttachmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskAttachment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskAttachmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskAttachmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskAttachment).
func (m *TaskAttachmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskAttachmentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.task != nil {
		fields = append(fields, taskattachment.FieldTaskID)
	}
	if m.project != nil {
		fields = append(fields, taskattachment.FieldProjectID)
	}
	if m.user != nil {
		fields = append(fields, taskattachment.FieldUserID)
	}
	if m.filename != nil {
		fields = append(fields, taskattachment.FieldFilename)
	}
	if m.file_type != nil {
		fields = append(fields, taskattachment.FieldFileType)
	}
	if m.content_type != nil {
		fields = append(fields, taskattachment.FieldContentType)
	}
	if m.file_size != nil {
		fields = append(fields, taskattachment.FieldFileSize)
	}
	if m.cloudinary_url != nil {
		fields = append(fields, taskattachment.FieldCloudinaryURL)
	}
	if m.cloudinary_public_id != nil {
		fields = append(fields, taskattachment.FieldCloudinaryPublicID)
	}
	if m.alt_name != nil {
		fields = append(fields, taskattachment.FieldAltName)
	}
	if m.created_at != nil {
		fields = append(fields, taskattachment.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskAttachmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskattachment.FieldTaskID:
		return m.TaskID()
	case taskattachment.FieldProjectID:
		return m.ProjectID()
	case taskattachment.FieldUserID:
		return m.UserID()
	case taskattachment.FieldFilename:
		return m.Filename()
	case taskattachment.FieldFileType:
		return m.FileType()
	case taskattachment.FieldContentType:
		return m.ContentType()
	case taskattachment.FieldFileSize:
		return m.FileSize()
	case taskattachment.FieldCloudinaryURL:
		return m.CloudinaryURL()
	case taskattachment.FieldCloudinaryPublicID:
		return m.CloudinaryPublicID()
	case taskattachment.FieldAltName:
		return m.AltName()
	case taskattachment.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskAttachmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskattachment.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskattachment.FieldProjectID:
		return m.OldProjectID(ctx)
	case taskattachment.FieldUserID:
		return m.OldUserID(ctx)
	case taskattachment.FieldFilename:
		return m.OldFilename(ctx)
	case taskattachment.FieldFileType:
		return m.OldFileType(ctx)
	case taskattachment.FieldContentType:
		return m.OldContentType(ctx)
	case taskattachment.FieldFileSize:
		return m.OldFileSize(ctx)
	case taskattachment.FieldCloudinaryURL:
		return m.OldCloudinaryURL(ctx)
	case taskattachment.FieldCloudinaryPublicID:
		return m.OldCloudinaryPublicID(ctx)
	case taskattachment.FieldAltName:
		return m.OldAltName(ctx)
	case taskattachment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskAttachment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskAttachmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskattachment.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskattachment.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case taskattachment.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case taskattachment.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case taskattachment.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case taskattachment.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case taskattachment.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case taskattachment.FieldCloudinaryURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudinaryURL(v)
		return nil
	case taskattachment.FieldCloudinaryPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloudinaryPublicID(v)
		return nil
	case taskattachment.FieldAltName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAltName(v)
		return nil
	case taskattachment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskAttachment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskAttachmentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, taskattachment.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskAttachmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case taskattachment.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskAttachmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case taskattachment.FieldFileSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown TaskAttachment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskAttachmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskAttachmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskAttachmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskAttachment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskAttachmentMutation) ResetField(name string) error {
	switch name {
	case taskattachment.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskattachment.FieldProjectID:
		m.ResetProjectID()
		return nil
	case taskattachment.FieldUserID:
		m.ResetUserID()
		return nil
	case taskattachment.FieldFilename:
		m.ResetFilename()
		return nil
	case taskattachment.FieldFileType:
		m.ResetFileType()
		return nil
	case taskattachment.FieldContentType:
		m.ResetContentType()
		return nil
	case taskattachment.FieldFileSize:
		m.ResetFileSize()
		return nil
	case taskattachment.FieldCloudinaryURL:
		m.ResetCloudinaryURL()
		return nil
	case taskattachment.FieldCloudinaryPublicID:
		m.ResetCloudinaryPublicID()
		return nil
	case taskattachment.FieldAltName:
		m.ResetAltName()
		return nil
	case taskattachment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskAttachment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskAttachmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.task != nil {
		edges = append(edges, taskattachment.EdgeTask)
	}
	if m.project != nil {
		edges = append(edges, taskattachment.EdgeProject)
	}
	if m.user != nil {
		edges = append(edges, taskattachment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskAttachmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskattachment.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskattachment.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case taskattachment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskAttachmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskAttachmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskAttachmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtask {
		edges = append(edges, taskattachment.EdgeTask)
	}
	if m.clearedproject {
		edges = append(edges, taskattachment.EdgeProject)
	}
	if m.cleareduser {
		edges = append(edges, taskattachment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskAttachmentMutation) EdgeCleared(name string) bool {
	switch name {
	case taskattachment.EdgeTask:
		return m.clearedtask
	case taskattachment.EdgeProject:
		return m.clearedproject
	case taskattachment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskAttachmentMutation) ClearEdge(name string) error {
	switch name {
	case taskattachment.EdgeTask:
		m.ClearTask()
		return nil
	case taskattachment.EdgeProject:
		m.ClearProject()
		return nil
	case taskattachment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TaskAttachment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskAttachmentMutation) ResetEdge(name string) error {
	switch name {
	case taskattachment.EdgeTask:
		m.ResetTask()
		return nil
	case taskattachment.EdgeProject:
		m.ResetProject()
		return nil
	case taskattachment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TaskAttachment edge %s", name)
}

// TaskCommentMutation represents an operation that mutates the TaskComment nodes in the graph.
type TaskCommentMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	comment       *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	task          *int64
	clearedtask   bool
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TaskComment, error)
	predicates    []predicate.TaskComment
}

var _ ent.Mutation = (*TaskCommentMutation)(nil)

// taskcommentOption allows management of the mutation configuration using functional options.
type taskcommentOption func(*TaskCommentMutation)

// newTaskCommentMutation creates new mutation for the TaskComment entity.
func newTaskCommentMutation(c config, op Op, opts ...taskcommentOption) *TaskCommentMutation {
	m := &TaskCommentMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskCommentID sets the ID field of the mutation.
func withTaskCommentID(id int64) taskcommentOption {
	return func(m *TaskCommentMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskComment
		)
		m.oldValue = func(ctx context.Context) (*TaskComment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskComment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskComment sets the old TaskComment of the mutation.
func withTaskComment(node *TaskComment) taskcommentOption {
	return func(m *TaskCommentMutation) {
		m.oldValue = func(context.Context) (*TaskComment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskCommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskCommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskComment entities.
func (m *TaskCommentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskCommentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskCommentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskComment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskCommentMutation) SetTaskID(i int64) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskCommentMutation) TaskID() (r int64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskComment entity.
// If the TaskComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCommentMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskCommentMutation) ResetTaskID() {
	m.task = nil
}

// SetUserID sets the "user_id" field.
func (m *TaskCommentMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TaskCommentMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TaskComment entity.
// If the TaskComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCommentMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TaskCommentMutation) ResetUserID() {
	m.user = nil
}

// SetComment sets the "comment" field.
func (m *TaskCommentMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *TaskCommentMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the TaskComment entity.
// If the TaskComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCommentMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ResetComment resets all changes to the "comment" field.
func (m *TaskCommentMutation) ResetComment() {
	m.comment = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskCommentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskCommentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskComment entity.
// If the TaskComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCommentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskCommentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskCommentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskCommentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskComment entity.
// If the TaskComment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskCommentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskCommentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskCommentMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[taskcomment.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskCommentMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskCommentMutation) TaskIDs() (ids []int64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskCommentMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TaskCommentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[taskcomment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TaskCommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TaskCommentMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TaskCommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TaskCommentMutation builder.
func (m *TaskCommentMutation) Where(ps ...predicate.TaskComment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskCommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskCommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskComment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskCommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskCommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskComment).
func (m *TaskCommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskCommentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.task != nil {
		fields = append(fields, taskcomment.FieldTaskID)
	}
	if m.user != nil {
		fields = append(fields, taskcomment.FieldUserID)
	}
	if m.comment != nil {
		fields = append(fields, taskcomment.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, taskcomment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskcomment.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskCommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskcomment.FieldTaskID:
		return m.TaskID()
	case taskcomment.FieldUserID:
		return m.UserID()
	case taskcomment.FieldComment:
		return m.Comment()
	case taskcomment.FieldCreatedAt:
		return m.CreatedAt()
	case taskcomment.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskCommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskcomment.FieldTaskID:
		return m.OldTaskID(ctx)
	case taskcomment.FieldUserID:
		return m.OldUserID(ctx)
	case taskcomment.FieldComment:
		return m.OldComment(ctx)
	case taskcomment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskcomment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskComment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskcomment.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case taskcomment.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case taskcomment.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case taskcomment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskcomment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskComment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskCommentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskCommentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskCommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskComment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskCommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskCommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskCommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskComment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskCommentMutation) ResetField(name string) error {
	switch name {
	case taskcomment.FieldTaskID:
		m.ResetTaskID()
		return nil
	case taskcomment.FieldUserID:
		m.ResetUserID()
		return nil
	case taskcomment.FieldComment:
		m.ResetComment()
		return nil
	case taskcomment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskcomment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskComment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskCommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, taskcomment.EdgeTask)
	}
	if m.user != nil {
		edges = append(edges, taskcomment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskCommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskcomment.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case taskcomment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskCommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskCommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskCommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, taskcomment.EdgeTask)
	}
	if m.cleareduser {
		edges = append(edges, taskcomment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskCommentMutation) EdgeCleared(name string) bool {
	switch name {
	case taskcomment.EdgeTask:
		return m.clearedtask
	case taskcomment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskCommentMutation) ClearEdge(name string) error {
	switch name {
	case taskcomment.EdgeTask:
		m.ClearTask()
		return nil
	case taskcomment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TaskComment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskCommentMutation) ResetEdge(name string) error {
	switch name {
	case taskcomment.EdgeTask:
		m.ResetTask()
		return nil
	case taskcomment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TaskComment edge %s", name)
}

// TaskTagMutation represents an operation that mutates the TaskTag nodes in the graph.
type TaskTagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	clearedFields map[string]struct{}
	task          *int64
	clearedtask   bool
	tag           *int64
	clearedtag    bool
	done          bool
	oldValue      func(context.Context) (*TaskTag, error)
	predicates    []predicate.TaskTag
}

var _ ent.Mutation = (*TaskTagMutation)(nil)

// tasktagOption allows management of the mutation configuration using functional options.
type tasktagOption func(*TaskTagMutation)

// newTaskTagMutation creates new mutation for the TaskTag entity.
func newTaskTagMutation(c config, op Op, opts ...tasktagOption) *TaskTagMutation {
	m := &TaskTagMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskTagID sets the ID field of the mutation.
func withTaskTagID(id int) tasktagOption {
	return func(m *TaskTagMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskTag
		)
		m.oldValue = func(ctx context.Context) (*TaskTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskTag sets the old TaskTag of the mutation.
func withTaskTag(node *TaskTag) tasktagOption {
	return func(m *TaskTagMutation) {
		m.oldValue = func(context.Context) (*TaskTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskTagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskTagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TaskTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTaskID sets the "task_id" field.
func (m *TaskTagMutation) SetTaskID(i int64) {
	m.task = &i
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *TaskTagMutation) TaskID() (r int64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldTaskID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *TaskTagMutation) ResetTaskID() {
	m.task = nil
}

// SetTagID sets the "tag_id" field.
func (m *TaskTagMutation) SetTagID(i int64) {
	m.tag = &i
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TaskTagMutation) TagID() (r int64, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldTagID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TaskTagMutation) ResetTagID() {
	m.tag = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskTag entity.
// If the TaskTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskTagMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTask clears the "task" edge to the Task entity.
func (m *TaskTagMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[tasktag.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the Task entity was cleared.
func (m *TaskTagMutation) TaskCleared() bool {
	return m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *TaskTagMutation) TaskIDs() (ids []int64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *TaskTagMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *TaskTagMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[tasktag.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *TaskTagMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TaskTagMutation) TagIDs() (ids []int64) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TaskTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// Where appends a list predicates to the TaskTagMutation builder.
func (m *TaskTagMutation) Where(ps ...predicate.TaskTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TaskTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TaskTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TaskTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TaskTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TaskTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TaskTag).
func (m *TaskTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskTagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.task != nil {
		fields = append(fields, tasktag.FieldTaskID)
	}
	if m.tag != nil {
		fields = append(fields, tasktag.FieldTagID)
	}
	if m.created_at != nil {
		fields = append(fields, tasktag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasktag.FieldTaskID:
		return m.TaskID()
	case tasktag.FieldTagID:
		return m.TagID()
	case tasktag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasktag.FieldTaskID:
		return m.OldTaskID(ctx)
	case tasktag.FieldTagID:
		return m.OldTagID(ctx)
	case tasktag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TaskTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasktag.FieldTaskID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case tasktag.FieldTagID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case tasktag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TaskTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskTagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskTagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskTagMutation) ResetField(name string) error {
	switch name {
	case tasktag.FieldTaskID:
		m.ResetTaskID()
		return nil
	case tasktag.FieldTagID:
		m.ResetTagID()
		return nil
	case tasktag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown TaskTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.task != nil {
		edges = append(edges, tasktag.EdgeTask)
	}
	if m.tag != nil {
		edges = append(edges, tasktag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasktag.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case tasktag.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskTagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtask {
		edges = append(edges, tasktag.EdgeTask)
	}
	if m.clearedtag {
		edges = append(edges, tasktag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskTagMutation) EdgeCleared(name string) bool {
	switch name {
	case tasktag.EdgeTask:
		return m.clearedtask
	case tasktag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskTagMutation) ClearEdge(name string) error {
	switch name {
	case tasktag.EdgeTask:
		m.ClearTask()
		return nil
	case tasktag.EdgeTag:
		m.ClearTag()
		return nil
	}
	return fmt.Errorf("unknown TaskTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskTagMutation) ResetEdge(name string) error {
	switch name {
	case tasktag.EdgeTask:
		m.ResetTask()
		return nil
	case tasktag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown TaskTag edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	name               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	owner              *int64
	clearedowner       bool
	members            map[int64]struct{}
	removedmembers     map[int64]struct{}
	clearedmembers     bool
	invitations        map[int64]struct{}
	removedinvitations map[int64]struct{}
	clearedinvitations bool
	projects           map[int64]struct{}
	removedprojects    map[int64]struct{}
	clearedprojects    bool
	sprints            map[int64]struct{}
	removedsprints     map[int64]struct{}
	clearedsprints     bool
	tags               map[int64]struct{}
	removedtags        map[int64]struct{}
	clearedtags        bool
	done               bool
	oldValue           func(context.Context) (*Team, error)
	predicates         []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int64) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *TeamMutation) SetOwnerID(i int64) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TeamMutation) OwnerID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TeamMutation) ResetOwnerID() {
	m.owner = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TeamMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[team.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TeamMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TeamMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddMemberIDs adds the "members" edge to the TeamMember entity by ids.
func (m *TeamMutation) AddMemberIDs(ids ...int64) {
	if m.members == nil {
		m.members = make(map[int64]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the TeamMember entity.
func (m *TeamMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the TeamMember entity was cleared.
func (m *TeamMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the TeamMember entity by IDs.
func (m *TeamMutation) RemoveMemberIDs(ids ...int64) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the TeamMember entity.
func (m *TeamMutation) RemovedMembersIDs() (ids []int64) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *TeamMutation) MembersIDs() (ids []int64) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *TeamMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddInvitationIDs adds the "invitations" edge to the TeamInvitation entity by ids.
func (m *TeamMutation) AddInvitationIDs(ids ...int64) {
	if m.invitations == nil {
		m.invitations = make(map[int64]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the TeamInvitation entity.
func (m *TeamMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the TeamInvitation entity was cleared.
func (m *TeamMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the TeamInvitation entity by IDs.
func (m *TeamMutation) RemoveInvitationIDs(ids ...int64) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the TeamInvitation entity.
func (m *TeamMutation) RemovedInvitationsIDs() (ids []int64) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *TeamMutation) InvitationsIDs() (ids []int64) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *TeamMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// AddProjectIDs adds the "projects" edge to the Project entity by ids.
func (m *TeamMutation) AddProjectIDs(ids ...int64) {
	if m.projects == nil {
		m.projects = make(map[int64]struct{})
	}
	for i := range ids {
		m.projects[ids[i]] = struct{}{}
	}
}

// ClearProjects clears the "projects" edge to the Project entity.
func (m *TeamMutation) ClearProjects() {
	m.clearedprojects = true
}

// ProjectsCleared reports if the "projects" edge to the Project entity was cleared.
func (m *TeamMutation) ProjectsCleared() bool {
	return m.clearedprojects
}

// RemoveProjectIDs removes the "projects" edge to the Project entity by IDs.
func (m *TeamMutation) RemoveProjectIDs(ids ...int64) {
	if m.removedprojects == nil {
		m.removedprojects = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.projects, ids[i])
		m.removedprojects[ids[i]] = struct{}{}
	}
}

// RemovedProjects returns the removed IDs of the "projects" edge to the Project entity.
func (m *TeamMutation) RemovedProjectsIDs() (ids []int64) {
	for id := range m.removedprojects {
		ids = append(ids, id)
	}
	return
}

// ProjectsIDs returns the "projects" edge IDs in the mutation.
func (m *TeamMutation) ProjectsIDs() (ids []int64) {
	for id := range m.projects {
		ids = append(ids, id)
	}
	return
}

// ResetProjects resets all changes to the "projects" edge.
func (m *TeamMutation) ResetProjects() {
	m.projects = nil
	m.clearedprojects = false
	m.removedprojects = nil
}

// AddSprintIDs adds the "sprints" edge to the Sprint entity by ids.
func (m *TeamMutation) AddSprintIDs(ids ...int64) {
	if m.sprints == nil {
		m.sprints = make(map[int64]struct{})
	}
	for i := range ids {
		m.sprints[ids[i]] = struct{}{}
	}
}

// ClearSprints clears the "sprints" edge to the Sprint entity.
func (m *TeamMutation) ClearSprints() {
	m.clearedsprints = true
}

// SprintsCleared reports if the "sprints" edge to the Sprint entity was cleared.
func (m *TeamMutation) SprintsCleared() bool {
	return m.clearedsprints
}

// RemoveSprintIDs removes the "sprints" edge to the Sprint entity by IDs.
func (m *TeamMutation) RemoveSprintIDs(ids ...int64) {
	if m.removedsprints == nil {
		m.removedsprints = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sprints, ids[i])
		m.removedsprints[ids[i]] = struct{}{}
	}
}

// RemovedSprints returns the removed IDs of the "sprints" edge to the Sprint entity.
func (m *TeamMutation) RemovedSprintsIDs() (ids []int64) {
	for id := range m.removedsprints {
		ids = append(ids, id)
	}
	return
}

// SprintsIDs returns the "sprints" edge IDs in the mutation.
func (m *TeamMutation) SprintsIDs() (ids []int64) {
	for id := range m.sprints {
		ids = append(ids, id)
	}
	return
}

// ResetSprints resets all changes to the "sprints" edge.
func (m *TeamMutation) ResetSprints() {
	m.sprints = nil
	m.clearedsprints = false
	m.removedsprints = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *TeamMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *TeamMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *TeamMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *TeamMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *TeamMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *TeamMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *TeamMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.owner != nil {
		fields = append(fields, team.FieldOwnerID)
	}
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldOwnerID:
		return m.OwnerID()
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.owner != nil {
		edges = append(edges, team.EdgeOwner)
	}
	if m.members != nil {
		edges = append(edges, team.EdgeMembers)
	}
	if m.invitations != nil {
		edges = append(edges, team.EdgeInvitations)
	}
	if m.projects != nil {
		edges = append(edges, team.EdgeProjects)
	}
	if m.sprints != nil {
		edges = append(edges, team.EdgeSprints)
	}
	if m.tags != nil {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.projects))
		for id := range m.projects {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSprints:
		ids := make([]ent.Value, 0, len(m.sprints))
		for id := range m.sprints {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedmembers != nil {
		edges = append(edges, team.EdgeMembers)
	}
	if m.removedinvitations != nil {
		edges = append(edges, team.EdgeInvitations)
	}
	if m.removedprojects != nil {
		edges = append(edges, team.EdgeProjects)
	}
	if m.removedsprints != nil {
		edges = append(edges, team.EdgeSprints)
	}
	if m.removedtags != nil {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeProjects:
		ids := make([]ent.Value, 0, len(m.removedprojects))
		for id := range m.removedprojects {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeSprints:
		ids := make([]ent.Value, 0, len(m.removedsprints))
		for id := range m.removedsprints {
			ids = append(ids, id)
		}
		return ids
	case team.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedowner {
		edges = append(edges, team.EdgeOwner)
	}
	if m.clearedmembers {
		edges = append(edges, team.EdgeMembers)
	}
	if m.clearedinvitations {
		edges = append(edges, team.EdgeInvitations)
	}
	if m.clearedprojects {
		edges = append(edges, team.EdgeProjects)
	}
	if m.clearedsprints {
		edges = append(edges, team.EdgeSprints)
	}
	if m.clearedtags {
		edges = append(edges, team.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeOwner:
		return m.clearedowner
	case team.EdgeMembers:
		return m.clearedmembers
	case team.EdgeInvitations:
		return m.clearedinvitations
	case team.EdgeProjects:
		return m.clearedprojects
	case team.EdgeSprints:
		return m.clearedsprints
	case team.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeOwner:
		m.ResetOwner()
		return nil
	case team.EdgeMembers:
		m.ResetMembers()
		return nil
	case team.EdgeInvitations:
		m.ResetInvitations()
		return nil
	case team.EdgeProjects:
		m.ResetProjects()
		return nil
	case team.EdgeSprints:
		m.ResetSprints()
		return nil
	case team.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamInvitationMutation represents an operation that mutates the TeamInvitation nodes in the graph.
type TeamInvitationMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	invitee_email    *string
	status           *string
	acceptance_token *string
	invite_code      *string
	token_expires_at *time.Time
	created_at       *time.Time
	responded_at     *time.Time
	clearedFields    map[string]struct{}
	team             *int64
	clearedteam      bool
	inviter          *int64
	clearedinviter   bool
	invitee          *int64
	clearedinvitee   bool
	done             bool
	oldValue         func(context.Context) (*TeamInvitation, error)
	predicates       []predicate.TeamInvitation
}

var _ ent.Mutation = (*TeamInvitationMutation)(nil)

// teaminvitationOption allows management of the mutation configuration using functional options.
type teaminvitationOption func(*TeamInvitationMutation)

// newTeamInvitationMutation creates new mutation for the TeamInvitation entity.
func newTeamInvitationMutation(c config, op Op, opts ...teaminvitationOption) *TeamInvitationMutation {
	m := &TeamInvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamInvitationID sets the ID field of the mutation.
func withTeamInvitationID(id int64) teaminvitationOption {
	return func(m *TeamInvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamInvitation
		)
		m.oldValue = func(ctx context.Context) (*TeamInvitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamInvitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamInvitation sets the old TeamInvitation of the mutation.
func withTeamInvitation(node *TeamInvitation) teaminvitationOption {
	return func(m *TeamInvitationMutation) {
		m.oldValue = func(context.Context) (*TeamInvitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamInvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamInvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamInvitation entities.
func (m *TeamInvitationMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamInvitationMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamInvitationMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamInvitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamID sets the "team_id" field.
func (m *TeamInvitationMutation) SetTeamID(i int64) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamInvitationMutation) TeamID() (r int64, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldTeamID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamInvitationMutation) ResetTeamID() {
	m.team = nil
}

// SetInviterID sets the "inviter_id" field.
func (m *TeamInvitationMutation) SetInviterID(i int64) {
	m.inviter = &i
}

// InviterID returns the value of the "inviter_id" field in the mutation.
func (m *TeamInvitationMutation) InviterID() (r int64, exists bool) {
	v := m.inviter
	if v == nil {
		return
	}
	return *v, true
}

// OldInviterID returns the old "inviter_id" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldInviterID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviterID: %w", err)
	}
	return oldValue.InviterID, nil
}

// ResetInviterID resets all changes to the "inviter_id" field.
func (m *TeamInvitationMutation) ResetInviterID() {
	m.inviter = nil
}

// SetInviteeEmail sets the "invitee_email" field.
func (m *TeamInvitationMutation) SetInviteeEmail(s string) {
	m.invitee_email = &s
}

// InviteeEmail returns the value of the "invitee_email" field in the mutation.
func (m *TeamInvitationMutation) InviteeEmail() (r string, exists bool) {
	v := m.invitee_email
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeEmail returns the old "invitee_email" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldInviteeEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeEmail: %w", err)
	}
	return oldValue.InviteeEmail, nil
}

// ResetInviteeEmail resets all changes to the "invitee_email" field.
func (m *TeamInvitationMutation) ResetInviteeEmail() {
	m.invitee_email = nil
}

// SetInviteeID sets the "invitee_id" field.
func (m *TeamInvitationMutation) SetInviteeID(i int64) {
	m.invitee = &i
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *TeamInvitationMutation) InviteeID() (r int64, exists bool) {
	v := m.invitee
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldInviteeID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ClearInviteeID clears the value of the "invitee_id" field.
func (m *TeamInvitationMutation) ClearInviteeID() {
	m.invitee = nil
	m.clearedFields[teaminvitation.FieldInviteeID] = struct{}{}
}

// InviteeIDCleared returns if the "invitee_id" field was cleared in this mutation.
func (m *TeamInvitationMutation) InviteeIDCleared() bool {
	_, ok := m.clearedFields[teaminvitation.FieldInviteeID]
	return ok
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *TeamInvitationMutation) ResetInviteeID() {
	m.invitee = nil
	delete(m.clearedFields, teaminvitation.FieldInviteeID)
}

// SetStatus sets the "status" field.
func (m *TeamInvitationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TeamInvitationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TeamInvitationMutation) ResetStatus() {
	m.status = nil
}

// SetAcceptanceToken sets the "acceptance_token" field.
func (m *TeamInvitationMutation) SetAcceptanceToken(s string) {
	m.acceptance_token = &s
}

// AcceptanceToken returns the value of the "acceptance_token" field in the mutation.
func (m *TeamInvitationMutation) AcceptanceToken() (r string, exists bool) {
	v := m.acceptance_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptanceToken returns the old "acceptance_token" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldAcceptanceToken(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptanceToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptanceToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptanceToken: %w", err)
	}
	return oldValue.AcceptanceToken, nil
}

// ClearAcceptanceToken clears the value of the "acceptance_token" field.
func (m *TeamInvitationMutation) ClearAcceptanceToken() {
	m.acceptance_token = nil
	m.clearedFields[teaminvitation.FieldAcceptanceToken] = struct{}{}
}

// AcceptanceTokenCleared returns if the "acceptance_token" field was cleared in this mutation.
func (m *TeamInvitationMutation) AcceptanceTokenCleared() bool {
	_, ok := m.clearedFields[teaminvitation.FieldAcceptanceToken]
	return ok
}

// ResetAcceptanceToken resets all changes to the "acceptance_token" field.
func (m *TeamInvitationMutation) ResetAcceptanceToken() {
	m.acceptance_token = nil
	delete(m.clearedFields, teaminvitation.FieldAcceptanceToken)
}

// SetInviteCode sets the "invite_code" field.
func (m *TeamInvitationMutation) SetInviteCode(s string) {
	m.invite_code = &s
}

// InviteCode returns the value of the "invite_code" field in the mutation.
func (m *TeamInvitationMutation) InviteCode() (r string, exists bool) {
	v := m.invite_code
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteCode returns the old "invite_code" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldInviteCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteCode: %w", err)
	}
	return oldValue.InviteCode, nil
}

// ClearInviteCode clears the value of the "invite_code" field.
func (m *TeamInvitationMutation) ClearInviteCode() {
	m.invite_code = nil
	m.clearedFields[teaminvitation.FieldInviteCode] = struct{}{}
}

// InviteCodeCleared returns if the "invite_code" field was cleared in this mutation.
func (m *TeamInvitationMutation) InviteCodeCleared() bool {
	_, ok := m.clearedFields[teaminvitation.FieldInviteCode]
	return ok
}

// ResetInviteCode resets all changes to the "invite_code" field.
func (m *TeamInvitationMutation) ResetInviteCode() {
	m.invite_code = nil
	delete(m.clearedFields, teaminvitation.FieldInviteCode)
}

// SetTokenExpiresAt sets the "token_expires_at" field.
func (m *TeamInvitationMutation) SetTokenExpiresAt(t time.Time) {
	m.token_expires_at = &t
}

// TokenExpiresAt returns the value of the "token_expires_at" field in the mutation.
func (m *TeamInvitationMutation) TokenExpiresAt() (r time.Time, exists bool) {
	v := m.token_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenExpiresAt returns the old "token_expires_at" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldTokenExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenExpiresAt: %w", err)
	}
	return oldValue.TokenExpiresAt, nil
}

// ClearTokenExpiresAt clears the value of the "token_expires_at" field.
func (m *TeamInvitationMutation) ClearTokenExpiresAt() {
	m.token_expires_at = nil
	m.clearedFields[teaminvitation.FieldTokenExpiresAt] = struct{}{}
}

// TokenExpiresAtCleared returns if the "token_expires_at" field was cleared in this mutation.
func (m *TeamInvitationMutation) TokenExpiresAtCleared() bool {
	_, ok := m.clearedFields[teaminvitation.FieldTokenExpiresAt]
	return ok
}

// ResetTokenExpiresAt resets all changes to the "token_expires_at" field.
func (m *TeamInvitationMutation) ResetTokenExpiresAt() {
	m.token_expires_at = nil
	delete(m.clearedFields, teaminvitation.FieldTokenExpiresAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamInvitationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamInvitationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamInvitationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRespondedAt sets the "responded_at" field.
func (m *TeamInvitationMutation) SetRespondedAt(t time.Time) {
	m.responded_at = &t
}

// RespondedAt returns the value of the "responded_at" field in the mutation.
func (m *TeamInvitationMutation) RespondedAt() (r time.Time, exists bool) {
	v := m.responded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRespondedAt returns the old "responded_at" field's value of the TeamInvitation entity.
// If the TeamInvitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamInvitationMutation) OldRespondedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRespondedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRespondedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespondedAt: %w", err)
	}
	return oldValue.RespondedAt, nil
}

// ClearRespondedAt clears the value of the "responded_at" field.
func (m *TeamInvitationMutation) ClearRespondedAt() {
	m.responded_at = nil
	m.clearedFields[teaminvitation.FieldRespondedAt] = struct{}{}
}

// RespondedAtCleared returns if the "responded_at" field was cleared in this mutation.
func (m *TeamInvitationMutation) RespondedAtCleared() bool {
	_, ok := m.clearedFields[teaminvitation.FieldRespondedAt]
	return ok
}

// ResetRespondedAt resets all changes to the "responded_at" field.
func (m *TeamInvitationMutation) ResetRespondedAt() {
	m.responded_at = nil
	delete(m.clearedFields, teaminvitation.FieldRespondedAt)
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TeamInvitationMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[teaminvitation.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TeamInvitationMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TeamInvitationMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TeamInvitationMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// ClearInviter clears the "inviter" edge to the User entity.
func (m *TeamInvitationMutation) ClearInviter() {
	m.clearedinviter = true
	m.clearedFields[teaminvitation.FieldInviterID] = struct{}{}
}

// InviterCleared reports if the "inviter" edge to the User entity was cleared.
func (m *TeamInvitationMutation) InviterCleared() bool {
	return m.clearedinviter
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *TeamInvitationMutation) InviterIDs() (ids []int64) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *TeamInvitationMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// ClearInvitee clears the "invitee" edge to the User entity.
func (m *TeamInvitationMutation) ClearInvitee() {
	m.clearedinvitee = true
	m.clearedFields[teaminvitation.FieldInviteeID] = struct{}{}
}

// InviteeCleared reports if the "invitee" edge to the User entity was cleared.
func (m *TeamInvitationMutation) InviteeCleared() bool {
	return m.InviteeIDCleared() || m.clearedinvitee
}

// InviteeIDs returns the "invitee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteeID instead. It exists only for internal usage by the builders.
func (m *TeamInvitationMutation) InviteeIDs() (ids []int64) {
	if id := m.invitee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitee resets all changes to the "invitee" edge.
func (m *TeamInvitationMutation) ResetInvitee() {
	m.invitee = nil
	m.clearedinvitee = false
}

// Where appends a list predicates to the TeamInvitationMutation builder.
func (m *TeamInvitationMutation) Where(ps ...predicate.TeamInvitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamInvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamInvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamInvitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamInvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamInvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamInvitation).
func (m *TeamInvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamInvitationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.team != nil {
		fields = append(fields, teaminvitation.FieldTeamID)
	}
	if m.inviter != nil {
		fields = append(fields, teaminvitation.FieldInviterID)
	}
	if m.invitee_email != nil {
		fields = append(fields, teaminvitation.FieldInviteeEmail)
	}
	if m.invitee != nil {
		fields = append(fields, teaminvitation.FieldInviteeID)
	}
	if m.status != nil {
		fields = append(fields, teaminvitation.FieldStatus)
	}
	if m.acceptance_token != nil {
		fields = append(fields, teaminvitation.FieldAcceptanceToken)
	}
	if m.invite_code != nil {
		fields = append(fields, teaminvitation.FieldInviteCode)
	}
	if m.token_expires_at != nil {
		fields = append(fields, teaminvitation.FieldTokenExpiresAt)
	}
	if m.created_at != nil {
		fields = append(fields, teaminvitation.FieldCreatedAt)
	}
	if m.responded_at != nil {
		fields = append(fields, teaminvitation.FieldRespondedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamInvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teaminvitation.FieldTeamID:
		return m.TeamID()
	case teaminvitation.FieldInviterID:
		return m.InviterID()
	case teaminvitation.FieldInviteeEmail:
		return m.InviteeEmail()
	case teaminvitation.FieldInviteeID:
		return m.InviteeID()
	case teaminvitation.FieldStatus:
		return m.Status()
	case teaminvitation.FieldAcceptanceToken:
		return m.AcceptanceToken()
	case teaminvitation.FieldInviteCode:
		return m.InviteCode()
	case teaminvitation.FieldTokenExpiresAt:
		return m.TokenExpiresAt()
	case teaminvitation.FieldCreatedAt:
		return m.CreatedAt()
	case teaminvitation.FieldRespondedAt:
		return m.RespondedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamInvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teaminvitation.FieldTeamID:
		return m.OldTeamID(ctx)
	case teaminvitation.FieldInviterID:
		return m.OldInviterID(ctx)
	case teaminvitation.FieldInviteeEmail:
		return m.OldInviteeEmail(ctx)
	case teaminvitation.FieldInviteeID:
		return m.OldInviteeID(ctx)
	case teaminvitation.FieldStatus:
		return m.OldStatus(ctx)
	case teaminvitation.FieldAcceptanceToken:
		return m.OldAcceptanceToken(ctx)
	case teaminvitation.FieldInviteCode:
		return m.OldInviteCode(ctx)
	case teaminvitation.FieldTokenExpiresAt:
		return m.OldTokenExpiresAt(ctx)
	case teaminvitation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teaminvitation.FieldRespondedAt:
		return m.OldRespondedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeamInvitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamInvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teaminvitation.FieldTeamID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teaminvitation.FieldInviterID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviterID(v)
		return nil
	case teaminvitation.FieldInviteeEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeEmail(v)
		return nil
	case teaminvitation.FieldInviteeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	case teaminvitation.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case teaminvitation.FieldAcceptanceToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptanceToken(v)
		return nil
	case teaminvitation.FieldInviteCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteCode(v)
		return nil
	case teaminvitation.FieldTokenExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenExpiresAt(v)
		return nil
	case teaminvitation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teaminvitation.FieldRespondedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespondedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeamInvitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamInvitationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamInvitationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamInvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamInvitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamInvitationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teaminvitation.FieldInviteeID) {
		fields = append(fields, teaminvitation.FieldInviteeID)
	}
	if m.FieldCleared(teaminvitation.FieldAcceptanceToken) {
		fields = append(fields, teaminvitation.FieldAcceptanceToken)
	}
	if m.FieldCleared(teaminvitation.FieldInviteCode) {
		fields = append(fields, teaminvitation.FieldInviteCode)
	}
	if m.FieldCleared(teaminvitation.FieldTokenExpiresAt) {
		fields = append(fields, teaminvitation.FieldTokenExpiresAt)
	}
	if m.FieldCleared(teaminvitation.FieldRespondedAt) {
		fields = append(fields, teaminvitation.FieldRespondedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamInvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamInvitationMutation) ClearField(name string) error {
	switch name {
	case teaminvitation.FieldInviteeID:
		m.ClearInviteeID()
		return nil
	case teaminvitation.FieldAcceptanceToken:
		m.ClearAcceptanceToken()
		return nil
	case teaminvitation.FieldInviteCode:
		m.ClearInviteCode()
		return nil
	case teaminvitation.FieldTokenExpiresAt:
		m.ClearTokenExpiresAt()
		return nil
	case teaminvitation.FieldRespondedAt:
		m.ClearRespondedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamInvitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamInvitationMutation) ResetField(name string) error {
	switch name {
	case teaminvitation.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teaminvitation.FieldInviterID:
		m.ResetInviterID()
		return nil
	case teaminvitation.FieldInviteeEmail:
		m.ResetInviteeEmail()
		return nil
	case teaminvitation.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	case teaminvitation.FieldStatus:
		m.ResetStatus()
		return nil
	case teaminvitation.FieldAcceptanceToken:
		m.ResetAcceptanceToken()
		return nil
	case teaminvitation.FieldInviteCode:
		m.ResetInviteCode()
		return nil
	case teaminvitation.FieldTokenExpiresAt:
		m.ResetTokenExpiresAt()
		return nil
	case teaminvitation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teaminvitation.FieldRespondedAt:
		m.ResetRespondedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamInvitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamInvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.team != nil {
		edges = append(edges, teaminvitation.EdgeTeam)
	}
	if m.inviter != nil {
		edges = append(edges, teaminvitation.EdgeInviter)
	}
	if m.invitee != nil {
		edges = append(edges, teaminvitation.EdgeInvitee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamInvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teaminvitation.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case teaminvitation.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	case teaminvitation.EdgeInvitee:
		if id := m.invitee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamInvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamInvitationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamInvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedteam {
		edges = append(edges, teaminvitation.EdgeTeam)
	}
	if m.clearedinviter {
		edges = append(edges, teaminvitation.EdgeInviter)
	}
	if m.clearedinvitee {
		edges = append(edges, teaminvitation.EdgeInvitee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamInvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case teaminvitation.EdgeTeam:
		return m.clearedteam
	case teaminvitation.EdgeInviter:
		return m.clearedinviter
	case teaminvitation.EdgeInvitee:
		return m.clearedinvitee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamInvitationMutation) ClearEdge(name string) error {
	switch name {
	case teaminvitation.EdgeTeam:
		m.ClearTeam()
		return nil
	case teaminvitation.EdgeInviter:
		m.ClearInviter()
		return nil
	case teaminvitation.EdgeInvitee:
		m.ClearInvitee()
		return nil
	}
	return fmt.Errorf("unknown TeamInvitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamInvitationMutation) ResetEdge(name string) error {
	switch name {
	case teaminvitation.EdgeTeam:
		m.ResetTeam()
		return nil
	case teaminvitation.EdgeInviter:
		m.ResetInviter()
		return nil
	case teaminvitation.EdgeInvitee:
		m.ResetInvitee()
		return nil
	}
	return fmt.Errorf("unknown TeamInvitation edge %s", name)
}

// TeamMemberMutation represents an operation that mutates the TeamMember nodes in the graph.
type TeamMemberMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	role          *string
	status        *string
	joined_at     *time.Time
	clearedFields map[string]struct{}
	team          *int64
	clearedteam   bool
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*TeamMember, error)
	predicates    []predicate.TeamMember
}

var _ ent.Mutation = (*TeamMemberMutation)(nil)

// teammemberOption allows management of the mutation configuration using functional options.
type teammemberOption func(*TeamMemberMutation)

// newTeamMemberMutation creates new mutation for the TeamMember entity.
func newTeamMemberMutation(c config, op Op, opts ...teammemberOption) *TeamMemberMutation {
	m := &TeamMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamMemberID sets the ID field of the mutation.
func withTeamMemberID(id int64) teammemberOption {
	return func(m *TeamMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamMember
		)
		m.oldValue = func(ctx context.Context) (*TeamMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamMember sets the old TeamMember of the mutation.
func withTeamMember(node *TeamMember) teammemberOption {
	return func(m *TeamMemberMutation) {
		m.oldValue = func(context.Context) (*TeamMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamMember entities.
func (m *TeamMemberMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMemberMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMemberMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTeamID sets the "team_id" field.
func (m *TeamMemberMutation) SetTeamID(i int64) {
	m.team = &i
}

// TeamID returns the value of the "team_id" field in the mutation.
func (m *TeamMemberMutation) TeamID() (r int64, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldTeamID returns the old "team_id" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldTeamID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeamID: %w", err)
	}
	return oldValue.TeamID, nil
}

// ResetTeamID resets all changes to the "team_id" field.
func (m *TeamMemberMutation) ResetTeamID() {
	m.team = nil
}

// SetUserID sets the "user_id" field.
func (m *TeamMemberMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *TeamMemberMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *TeamMemberMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *TeamMemberMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *TeamMemberMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *TeamMemberMutation) ResetRole() {
	m.role = nil
}

// SetStatus sets the "status" field.
func (m *TeamMemberMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *TeamMemberMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TeamMemberMutation) ResetStatus() {
	m.status = nil
}

// SetJoinedAt sets the "joined_at" field.
func (m *TeamMemberMutation) SetJoinedAt(t time.Time) {
	m.joined_at = &t
}

// JoinedAt returns the value of the "joined_at" field in the mutation.
func (m *TeamMemberMutation) JoinedAt() (r time.Time, exists bool) {
	v := m.joined_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinedAt returns the old "joined_at" field's value of the TeamMember entity.
// If the TeamMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMemberMutation) OldJoinedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinedAt: %w", err)
	}
	return oldValue.JoinedAt, nil
}

// ResetJoinedAt resets all changes to the "joined_at" field.
func (m *TeamMemberMutation) ResetJoinedAt() {
	m.joined_at = nil
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *TeamMemberMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[teammember.FieldTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *TeamMemberMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *TeamMemberMutation) TeamIDs() (ids []int64) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *TeamMemberMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *TeamMemberMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[teammember.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *TeamMemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *TeamMemberMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *TeamMemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the TeamMemberMutation builder.
func (m *TeamMemberMutation) Where(ps ...predicate.TeamMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamMember).
func (m *TeamMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMemberMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.team != nil {
		fields = append(fields, teammember.FieldTeamID)
	}
	if m.user != nil {
		fields = append(fields, teammember.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, teammember.FieldRole)
	}
	if m.status != nil {
		fields = append(fields, teammember.FieldStatus)
	}
	if m.joined_at != nil {
		fields = append(fields, teammember.FieldJoinedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teammember.FieldTeamID:
		return m.TeamID()
	case teammember.FieldUserID:
		return m.UserID()
	case teammember.FieldRole:
		return m.Role()
	case teammember.FieldStatus:
		return m.Status()
	case teammember.FieldJoinedAt:
		return m.JoinedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teammember.FieldTeamID:
		return m.OldTeamID(ctx)
	case teammember.FieldUserID:
		return m.OldUserID(ctx)
	case teammember.FieldRole:
		return m.OldRole(ctx)
	case teammember.FieldStatus:
		return m.OldStatus(ctx)
	case teammember.FieldJoinedAt:
		return m.OldJoinedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeamMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teammember.FieldTeamID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeamID(v)
		return nil
	case teammember.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case teammember.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case teammember.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case teammember.FieldJoinedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeamMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TeamMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TeamMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMemberMutation) ResetField(name string) error {
	switch name {
	case teammember.FieldTeamID:
		m.ResetTeamID()
		return nil
	case teammember.FieldUserID:
		m.ResetUserID()
		return nil
	case teammember.FieldRole:
		m.ResetRole()
		return nil
	case teammember.FieldStatus:
		m.ResetStatus()
		return nil
	case teammember.FieldJoinedAt:
		m.ResetJoinedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.team != nil {
		edges = append(edges, teammember.EdgeTeam)
	}
	if m.user != nil {
		edges = append(edges, teammember.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case teammember.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	case teammember.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedteam {
		edges = append(edges, teammember.EdgeTeam)
	}
	if m.cleareduser {
		edges = append(edges, teammember.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case teammember.EdgeTeam:
		return m.clearedteam
	case teammember.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMemberMutation) ClearEdge(name string) error {
	switch name {
	case teammember.EdgeTeam:
		m.ClearTeam()
		return nil
	case teammember.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown TeamMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMemberMutation) ResetEdge(name string) error {
	switch name {
	case teammember.EdgeTeam:
		m.ResetTeam()
		return nil
	case teammember.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown TeamMember edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int64
	email                              *string
	password_hash                      *string
	name                               *string
	is_admin                           *bool
	totp_secret                        *string
	totp_enabled                       *bool
	backup_codes                       *string
	password_changed_at                *time.Time
	invite_count                       *int
	addinvite_count                    *int
	created_at                         *time.Time
	updated_at                         *time.Time
	clearedFields                      map[string]struct{}
	owned_projects                     map[int64]struct{}
	removedowned_projects              map[int64]struct{}
	clearedowned_projects              bool
	owned_teams                        map[int64]struct{}
	removedowned_teams                 map[int64]struct{}
	clearedowned_teams                 bool
	team_memberships                   map[int64]struct{}
	removedteam_memberships            map[int64]struct{}
	clearedteam_memberships            bool
	project_memberships                map[int64]struct{}
	removedproject_memberships         map[int64]struct{}
	clearedproject_memberships         bool
	project_memberships_granted        map[int64]struct{}
	removedproject_memberships_granted map[int64]struct{}
	clearedproject_memberships_granted bool
	tasks_assigned                     map[int64]struct{}
	removedtasks_assigned              map[int64]struct{}
	clearedtasks_assigned              bool
	sprints                            map[int64]struct{}
	removedsprints                     map[int64]struct{}
	clearedsprints                     bool
	tags                               map[int64]struct{}
	removedtags                        map[int64]struct{}
	clearedtags                        bool
	api_keys                           map[int64]struct{}
	removedapi_keys                    map[int64]struct{}
	clearedapi_keys                    bool
	user_activities                    map[int64]struct{}
	removeduser_activities             map[int64]struct{}
	cleareduser_activities             bool
	task_comments                      map[int64]struct{}
	removedtask_comments               map[int64]struct{}
	clearedtask_comments               bool
	invites_sent                       map[int64]struct{}
	removedinvites_sent                map[int64]struct{}
	clearedinvites_sent                bool
	invites_received                   map[int64]struct{}
	removedinvites_received            map[int64]struct{}
	clearedinvites_received            bool
	team_invitations_sent              map[int64]struct{}
	removedteam_invitations_sent       map[int64]struct{}
	clearedteam_invitations_sent       bool
	team_invitations_received          map[int64]struct{}
	removedteam_invitations_received   map[int64]struct{}
	clearedteam_invitations_received   bool
	cloudinary_credentials             map[int64]struct{}
	removedcloudinary_credentials      map[int64]struct{}
	clearedcloudinary_credentials      bool
	task_attachments                   map[int64]struct{}
	removedtask_attachments            map[int64]struct{}
	clearedtask_attachments            bool
	wiki_pages_created                 map[int64]struct{}
	removedwiki_pages_created          map[int64]struct{}
	clearedwiki_pages_created          bool
	yjs_updates                        map[int64]struct{}
	removedyjs_updates                 map[int64]struct{}
	clearedyjs_updates                 bool
	done                               bool
	oldValue                           func(context.Context) (*User, error)
	predicates                         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetIsAdmin sets the "is_admin" field.
func (m *UserMutation) SetIsAdmin(b bool) {
	m.is_admin = &b
}

// IsAdmin returns the value of the "is_admin" field in the mutation.
func (m *UserMutation) IsAdmin() (r bool, exists bool) {
	v := m.is_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAdmin returns the old "is_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAdmin: %w", err)
	}
	return oldValue.IsAdmin, nil
}

// ResetIsAdmin resets all changes to the "is_admin" field.
func (m *UserMutation) ResetIsAdmin() {
	m.is_admin = nil
}

// SetTotpSecret sets the "totp_secret" field.
func (m *UserMutation) SetTotpSecret(s string) {
	m.totp_secret = &s
}

// TotpSecret returns the value of the "totp_secret" field in the mutation.
func (m *UserMutation) TotpSecret() (r string, exists bool) {
	v := m.totp_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecret returns the old "totp_secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecret(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecret: %w", err)
	}
	return oldValue.TotpSecret, nil
}

// ClearTotpSecret clears the value of the "totp_secret" field.
func (m *UserMutation) ClearTotpSecret() {
	m.totp_secret = nil
	m.clearedFields[user.FieldTotpSecret] = struct{}{}
}

// TotpSecretCleared returns if the "totp_secret" field was cleared in this mutation.
func (m *UserMutation) TotpSecretCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecret]
	return ok
}

// ResetTotpSecret resets all changes to the "totp_secret" field.
func (m *UserMutation) ResetTotpSecret() {
	m.totp_secret = nil
	delete(m.clearedFields, user.FieldTotpSecret)
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetBackupCodes sets the "backup_codes" field.
func (m *UserMutation) SetBackupCodes(s string) {
	m.backup_codes = &s
}

// BackupCodes returns the value of the "backup_codes" field in the mutation.
func (m *UserMutation) BackupCodes() (r string, exists bool) {
	v := m.backup_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldBackupCodes returns the old "backup_codes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBackupCodes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackupCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackupCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackupCodes: %w", err)
	}
	return oldValue.BackupCodes, nil
}

// ClearBackupCodes clears the value of the "backup_codes" field.
func (m *UserMutation) ClearBackupCodes() {
	m.backup_codes = nil
	m.clearedFields[user.FieldBackupCodes] = struct{}{}
}

// BackupCodesCleared returns if the "backup_codes" field was cleared in this mutation.
func (m *UserMutation) BackupCodesCleared() bool {
	_, ok := m.clearedFields[user.FieldBackupCodes]
	return ok
}

// ResetBackupCodes resets all changes to the "backup_codes" field.
func (m *UserMutation) ResetBackupCodes() {
	m.backup_codes = nil
	delete(m.clearedFields, user.FieldBackupCodes)
}

// SetPasswordChangedAt sets the "password_changed_at" field.
func (m *UserMutation) SetPasswordChangedAt(t time.Time) {
	m.password_changed_at = &t
}

// PasswordChangedAt returns the value of the "password_changed_at" field in the mutation.
func (m *UserMutation) PasswordChangedAt() (r time.Time, exists bool) {
	v := m.password_changed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordChangedAt returns the old "password_changed_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordChangedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordChangedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordChangedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordChangedAt: %w", err)
	}
	return oldValue.PasswordChangedAt, nil
}

// ClearPasswordChangedAt clears the value of the "password_changed_at" field.
func (m *UserMutation) ClearPasswordChangedAt() {
	m.password_changed_at = nil
	m.clearedFields[user.FieldPasswordChangedAt] = struct{}{}
}

// PasswordChangedAtCleared returns if the "password_changed_at" field was cleared in this mutation.
func (m *UserMutation) PasswordChangedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordChangedAt]
	return ok
}

// ResetPasswordChangedAt resets all changes to the "password_changed_at" field.
func (m *UserMutation) ResetPasswordChangedAt() {
	m.password_changed_at = nil
	delete(m.clearedFields, user.FieldPasswordChangedAt)
}

// SetInviteCount sets the "invite_count" field.
func (m *UserMutation) SetInviteCount(i int) {
	m.invite_count = &i
	m.addinvite_count = nil
}

// InviteCount returns the value of the "invite_count" field in the mutation.
func (m *UserMutation) InviteCount() (r int, exists bool) {
	v := m.invite_count
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteCount returns the old "invite_count" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldInviteCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteCount: %w", err)
	}
	return oldValue.InviteCount, nil
}

// AddInviteCount adds i to the "invite_count" field.
func (m *UserMutation) AddInviteCount(i int) {
	if m.addinvite_count != nil {
		*m.addinvite_count += i
	} else {
		m.addinvite_count = &i
	}
}

// AddedInviteCount returns the value that was added to the "invite_count" field in this mutation.
func (m *UserMutation) AddedInviteCount() (r int, exists bool) {
	v := m.addinvite_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetInviteCount resets all changes to the "invite_count" field.
func (m *UserMutation) ResetInviteCount() {
	m.invite_count = nil
	m.addinvite_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddOwnedProjectIDs adds the "owned_projects" edge to the Project entity by ids.
func (m *UserMutation) AddOwnedProjectIDs(ids ...int64) {
	if m.owned_projects == nil {
		m.owned_projects = make(map[int64]struct{})
	}
	for i := range ids {
		m.owned_projects[ids[i]] = struct{}{}
	}
}

// ClearOwnedProjects clears the "owned_projects" edge to the Project entity.
func (m *UserMutation) ClearOwnedProjects() {
	m.clearedowned_projects = true
}

// OwnedProjectsCleared reports if the "owned_projects" edge to the Project entity was cleared.
func (m *UserMutation) OwnedProjectsCleared() bool {
	return m.clearedowned_projects
}

// RemoveOwnedProjectIDs removes the "owned_projects" edge to the Project entity by IDs.
func (m *UserMutation) RemoveOwnedProjectIDs(ids ...int64) {
	if m.removedowned_projects == nil {
		m.removedowned_projects = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.owned_projects, ids[i])
		m.removedowned_projects[ids[i]] = struct{}{}
	}
}

// RemovedOwnedProjects returns the removed IDs of the "owned_projects" edge to the Project entity.
func (m *UserMutation) RemovedOwnedProjectsIDs() (ids []int64) {
	for id := range m.removedowned_projects {
		ids = append(ids, id)
	}
	return
}

// OwnedProjectsIDs returns the "owned_projects" edge IDs in the mutation.
func (m *UserMutation) OwnedProjectsIDs() (ids []int64) {
	for id := range m.owned_projects {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedProjects resets all changes to the "owned_projects" edge.
func (m *UserMutation) ResetOwnedProjects() {
	m.owned_projects = nil
	m.clearedowned_projects = false
	m.removedowned_projects = nil
}

// AddOwnedTeamIDs adds the "owned_teams" edge to the Team entity by ids.
func (m *UserMutation) AddOwnedTeamIDs(ids ...int64) {
	if m.owned_teams == nil {
		m.owned_teams = make(map[int64]struct{})
	}
	for i := range ids {
		m.owned_teams[ids[i]] = struct{}{}
	}
}

// ClearOwnedTeams clears the "owned_teams" edge to the Team entity.
func (m *UserMutation) ClearOwnedTeams() {
	m.clearedowned_teams = true
}

// OwnedTeamsCleared reports if the "owned_teams" edge to the Team entity was cleared.
func (m *UserMutation) OwnedTeamsCleared() bool {
	return m.clearedowned_teams
}

// RemoveOwnedTeamIDs removes the "owned_teams" edge to the Team entity by IDs.
func (m *UserMutation) RemoveOwnedTeamIDs(ids ...int64) {
	if m.removedowned_teams == nil {
		m.removedowned_teams = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.owned_teams, ids[i])
		m.removedowned_teams[ids[i]] = struct{}{}
	}
}

// RemovedOwnedTeams returns the removed IDs of the "owned_teams" edge to the Team entity.
func (m *UserMutation) RemovedOwnedTeamsIDs() (ids []int64) {
	for id := range m.removedowned_teams {
		ids = append(ids, id)
	}
	return
}

// OwnedTeamsIDs returns the "owned_teams" edge IDs in the mutation.
func (m *UserMutation) OwnedTeamsIDs() (ids []int64) {
	for id := range m.owned_teams {
		ids = append(ids, id)
	}
	return
}

// ResetOwnedTeams resets all changes to the "owned_teams" edge.
func (m *UserMutation) ResetOwnedTeams() {
	m.owned_teams = nil
	m.clearedowned_teams = false
	m.removedowned_teams = nil
}

// AddTeamMembershipIDs adds the "team_memberships" edge to the TeamMember entity by ids.
func (m *UserMutation) AddTeamMembershipIDs(ids ...int64) {
	if m.team_memberships == nil {
		m.team_memberships = make(map[int64]struct{})
	}
	for i := range ids {
		m.team_memberships[ids[i]] = struct{}{}
	}
}

// ClearTeamMemberships clears the "team_memberships" edge to the TeamMember entity.
func (m *UserMutation) ClearTeamMemberships() {
	m.clearedteam_memberships = true
}

// TeamMembershipsCleared reports if the "team_memberships" edge to the TeamMember entity was cleared.
func (m *UserMutation) TeamMembershipsCleared() bool {
	return m.clearedteam_memberships
}

// RemoveTeamMembershipIDs removes the "team_memberships" edge to the TeamMember entity by IDs.
func (m *UserMutation) RemoveTeamMembershipIDs(ids ...int64) {
	if m.removedteam_memberships == nil {
		m.removedteam_memberships = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.team_memberships, ids[i])
		m.removedteam_memberships[ids[i]] = struct{}{}
	}
}

// RemovedTeamMemberships returns the removed IDs of the "team_memberships" edge to the TeamMember entity.
func (m *UserMutation) RemovedTeamMembershipsIDs() (ids []int64) {
	for id := range m.removedteam_memberships {
		ids = append(ids, id)
	}
	return
}

// TeamMembershipsIDs returns the "team_memberships" edge IDs in the mutation.
func (m *UserMutation) TeamMembershipsIDs() (ids []int64) {
	for id := range m.team_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetTeamMemberships resets all changes to the "team_memberships" edge.
func (m *UserMutation) ResetTeamMemberships() {
	m.team_memberships = nil
	m.clearedteam_memberships = false
	m.removedteam_memberships = nil
}

// AddProjectMembershipIDs adds the "project_memberships" edge to the ProjectMember entity by ids.
func (m *UserMutation) AddProjectMembershipIDs(ids ...int64) {
	if m.project_memberships == nil {
		m.project_memberships = make(map[int64]struct{})
	}
	for i := range ids {
		m.project_memberships[ids[i]] = struct{}{}
	}
}

// ClearProjectMemberships clears the "project_memberships" edge to the ProjectMember entity.
func (m *UserMutation) ClearProjectMemberships() {
	m.clearedproject_memberships = true
}

// ProjectMembershipsCleared reports if the "project_memberships" edge to the ProjectMember entity was cleared.
func (m *UserMutation) ProjectMembershipsCleared() bool {
	return m.clearedproject_memberships
}

// RemoveProjectMembershipIDs removes the "project_memberships" edge to the ProjectMember entity by IDs.
func (m *UserMutation) RemoveProjectMembershipIDs(ids ...int64) {
	if m.removedproject_memberships == nil {
		m.removedproject_memberships = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.project_memberships, ids[i])
		m.removedproject_memberships[ids[i]] = struct{}{}
	}
}

// RemovedProjectMemberships returns the removed IDs of the "project_memberships" edge to the ProjectMember entity.
func (m *UserMutation) RemovedProjectMembershipsIDs() (ids []int64) {
	for id := range m.removedproject_memberships {
		ids = append(ids, id)
	}
	return
}

// ProjectMembershipsIDs returns the "project_memberships" edge IDs in the mutation.
func (m *UserMutation) ProjectMembershipsIDs() (ids []int64) {
	for id := range m.project_memberships {
		ids = append(ids, id)
	}
	return
}

// ResetProjectMemberships resets all changes to the "project_memberships" edge.
func (m *UserMutation) ResetProjectMemberships() {
	m.project_memberships = nil
	m.clearedproject_memberships = false
	m.removedproject_memberships = nil
}

// AddProjectMembershipsGrantedIDs adds the "project_memberships_granted" edge to the ProjectMember entity by ids.
func (m *UserMutation) AddProjectMembershipsGrantedIDs(ids ...int64) {
	if m.project_memberships_granted == nil {
		m.project_memberships_granted = make(map[int64]struct{})
	}
	for i := range ids {
		m.project_memberships_granted[ids[i]] = struct{}{}
	}
}

// ClearProjectMembershipsGranted clears the "project_memberships_granted" edge to the ProjectMember entity.
func (m *UserMutation) ClearProjectMembershipsGranted() {
	m.clearedproject_memberships_granted = true
}

// ProjectMembershipsGrantedCleared reports if the "project_memberships_granted" edge to the ProjectMember entity was cleared.
func (m *UserMutation) ProjectMembershipsGrantedCleared() bool {
	return m.clearedproject_memberships_granted
}

// RemoveProjectMembershipsGrantedIDs removes the "project_memberships_granted" edge to the ProjectMember entity by IDs.
func (m *UserMutation) RemoveProjectMembershipsGrantedIDs(ids ...int64) {
	if m.removedproject_memberships_granted == nil {
		m.removedproject_memberships_granted = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.project_memberships_granted, ids[i])
		m.removedproject_memberships_granted[ids[i]] = struct{}{}
	}
}

// RemovedProjectMembershipsGranted returns the removed IDs of the "project_memberships_granted" edge to the ProjectMember entity.
func (m *UserMutation) RemovedProjectMembershipsGrantedIDs() (ids []int64) {
	for id := range m.removedproject_memberships_granted {
		ids = append(ids, id)
	}
	return
}

// ProjectMembershipsGrantedIDs returns the "project_memberships_granted" edge IDs in the mutation.
func (m *UserMutation) ProjectMembershipsGrantedIDs() (ids []int64) {
	for id := range m.project_memberships_granted {
		ids = append(ids, id)
	}
	return
}

// ResetProjectMembershipsGranted resets all changes to the "project_memberships_granted" edge.
func (m *UserMutation) ResetProjectMembershipsGranted() {
	m.project_memberships_granted = nil
	m.clearedproject_memberships_granted = false
	m.removedproject_memberships_granted = nil
}

// AddTasksAssignedIDs adds the "tasks_assigned" edge to the Task entity by ids.
func (m *UserMutation) AddTasksAssignedIDs(ids ...int64) {
	if m.tasks_assigned == nil {
		m.tasks_assigned = make(map[int64]struct{})
	}
	for i := range ids {
		m.tasks_assigned[ids[i]] = struct{}{}
	}
}

// ClearTasksAssigned clears the "tasks_assigned" edge to the Task entity.
func (m *UserMutation) ClearTasksAssigned() {
	m.clearedtasks_assigned = true
}

// TasksAssignedCleared reports if the "tasks_assigned" edge to the Task entity was cleared.
func (m *UserMutation) TasksAssignedCleared() bool {
	return m.clearedtasks_assigned
}

// RemoveTasksAssignedIDs removes the "tasks_assigned" edge to the Task entity by IDs.
func (m *UserMutation) RemoveTasksAssignedIDs(ids ...int64) {
	if m.removedtasks_assigned == nil {
		m.removedtasks_assigned = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tasks_assigned, ids[i])
		m.removedtasks_assigned[ids[i]] = struct{}{}
	}
}

// RemovedTasksAssigned returns the removed IDs of the "tasks_assigned" edge to the Task entity.
func (m *UserMutation) RemovedTasksAssignedIDs() (ids []int64) {
	for id := range m.removedtasks_assigned {
		ids = append(ids, id)
	}
	return
}

// TasksAssignedIDs returns the "tasks_assigned" edge IDs in the mutation.
func (m *UserMutation) TasksAssignedIDs() (ids []int64) {
	for id := range m.tasks_assigned {
		ids = append(ids, id)
	}
	return
}

// ResetTasksAssigned resets all changes to the "tasks_assigned" edge.
func (m *UserMutation) ResetTasksAssigned() {
	m.tasks_assigned = nil
	m.clearedtasks_assigned = false
	m.removedtasks_assigned = nil
}

// AddSprintIDs adds the "sprints" edge to the Sprint entity by ids.
func (m *UserMutation) AddSprintIDs(ids ...int64) {
	if m.sprints == nil {
		m.sprints = make(map[int64]struct{})
	}
	for i := range ids {
		m.sprints[ids[i]] = struct{}{}
	}
}

// ClearSprints clears the "sprints" edge to the Sprint entity.
func (m *UserMutation) ClearSprints() {
	m.clearedsprints = true
}

// SprintsCleared reports if the "sprints" edge to the Sprint entity was cleared.
func (m *UserMutation) SprintsCleared() bool {
	return m.clearedsprints
}

// RemoveSprintIDs removes the "sprints" edge to the Sprint entity by IDs.
func (m *UserMutation) RemoveSprintIDs(ids ...int64) {
	if m.removedsprints == nil {
		m.removedsprints = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sprints, ids[i])
		m.removedsprints[ids[i]] = struct{}{}
	}
}

// RemovedSprints returns the removed IDs of the "sprints" edge to the Sprint entity.
func (m *UserMutation) RemovedSprintsIDs() (ids []int64) {
	for id := range m.removedsprints {
		ids = append(ids, id)
	}
	return
}

// SprintsIDs returns the "sprints" edge IDs in the mutation.
func (m *UserMutation) SprintsIDs() (ids []int64) {
	for id := range m.sprints {
		ids = append(ids, id)
	}
	return
}

// ResetSprints resets all changes to the "sprints" edge.
func (m *UserMutation) ResetSprints() {
	m.sprints = nil
	m.clearedsprints = false
	m.removedsprints = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *UserMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *UserMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *UserMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *UserMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *UserMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *UserMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *UserMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddUserActivityIDs adds the "user_activities" edge to the UserActivity entity by ids.
func (m *UserMutation) AddUserActivityIDs(ids ...int64) {
	if m.user_activities == nil {
		m.user_activities = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_activities[ids[i]] = struct{}{}
	}
}

// ClearUserActivities clears the "user_activities" edge to the UserActivity entity.
func (m *UserMutation) ClearUserActivities() {
	m.cleareduser_activities = true
}

// UserActivitiesCleared reports if the "user_activities" edge to the UserActivity entity was cleared.
func (m *UserMutation) UserActivitiesCleared() bool {
	return m.cleareduser_activities
}

// RemoveUserActivityIDs removes the "user_activities" edge to the UserActivity entity by IDs.
func (m *UserMutation) RemoveUserActivityIDs(ids ...int64) {
	if m.removeduser_activities == nil {
		m.removeduser_activities = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_activities, ids[i])
		m.removeduser_activities[ids[i]] = struct{}{}
	}
}

// RemovedUserActivities returns the removed IDs of the "user_activities" edge to the UserActivity entity.
func (m *UserMutation) RemovedUserActivitiesIDs() (ids []int64) {
	for id := range m.removeduser_activities {
		ids = append(ids, id)
	}
	return
}

// UserActivitiesIDs returns the "user_activities" edge IDs in the mutation.
func (m *UserMutation) UserActivitiesIDs() (ids []int64) {
	for id := range m.user_activities {
		ids = append(ids, id)
	}
	return
}

// ResetUserActivities resets all changes to the "user_activities" edge.
func (m *UserMutation) ResetUserActivities() {
	m.user_activities = nil
	m.cleareduser_activities = false
	m.removeduser_activities = nil
}

// AddTaskCommentIDs adds the "task_comments" edge to the TaskComment entity by ids.
func (m *UserMutation) AddTaskCommentIDs(ids ...int64) {
	if m.task_comments == nil {
		m.task_comments = make(map[int64]struct{})
	}
	for i := range ids {
		m.task_comments[ids[i]] = struct{}{}
	}
}

// ClearTaskComments clears the "task_comments" edge to the TaskComment entity.
func (m *UserMutation) ClearTaskComments() {
	m.clearedtask_comments = true
}

// TaskCommentsCleared reports if the "task_comments" edge to the TaskComment entity was cleared.
func (m *UserMutation) TaskCommentsCleared() bool {
	return m.clearedtask_comments
}

// RemoveTaskCommentIDs removes the "task_comments" edge to the TaskComment entity by IDs.
func (m *UserMutation) RemoveTaskCommentIDs(ids ...int64) {
	if m.removedtask_comments == nil {
		m.removedtask_comments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task_comments, ids[i])
		m.removedtask_comments[ids[i]] = struct{}{}
	}
}

// RemovedTaskComments returns the removed IDs of the "task_comments" edge to the TaskComment entity.
func (m *UserMutation) RemovedTaskCommentsIDs() (ids []int64) {
	for id := range m.removedtask_comments {
		ids = append(ids, id)
	}
	return
}

// TaskCommentsIDs returns the "task_comments" edge IDs in the mutation.
func (m *UserMutation) TaskCommentsIDs() (ids []int64) {
	for id := range m.task_comments {
		ids = append(ids, id)
	}
	return
}

// ResetTaskComments resets all changes to the "task_comments" edge.
func (m *UserMutation) ResetTaskComments() {
	m.task_comments = nil
	m.clearedtask_comments = false
	m.removedtask_comments = nil
}

// AddInvitesSentIDs adds the "invites_sent" edge to the Invite entity by ids.
func (m *UserMutation) AddInvitesSentIDs(ids ...int64) {
	if m.invites_sent == nil {
		m.invites_sent = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites_sent[ids[i]] = struct{}{}
	}
}

// ClearInvitesSent clears the "invites_sent" edge to the Invite entity.
func (m *UserMutation) ClearInvitesSent() {
	m.clearedinvites_sent = true
}

// InvitesSentCleared reports if the "invites_sent" edge to the Invite entity was cleared.
func (m *UserMutation) InvitesSentCleared() bool {
	return m.clearedinvites_sent
}

// RemoveInvitesSentIDs removes the "invites_sent" edge to the Invite entity by IDs.
func (m *UserMutation) RemoveInvitesSentIDs(ids ...int64) {
	if m.removedinvites_sent == nil {
		m.removedinvites_sent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites_sent, ids[i])
		m.removedinvites_sent[ids[i]] = struct{}{}
	}
}

// RemovedInvitesSent returns the removed IDs of the "invites_sent" edge to the Invite entity.
func (m *UserMutation) RemovedInvitesSentIDs() (ids []int64) {
	for id := range m.removedinvites_sent {
		ids = append(ids, id)
	}
	return
}

// InvitesSentIDs returns the "invites_sent" edge IDs in the mutation.
func (m *UserMutation) InvitesSentIDs() (ids []int64) {
	for id := range m.invites_sent {
		ids = append(ids, id)
	}
	return
}

// ResetInvitesSent resets all changes to the "invites_sent" edge.
func (m *UserMutation) ResetInvitesSent() {
	m.invites_sent = nil
	m.clearedinvites_sent = false
	m.removedinvites_sent = nil
}

// AddInvitesReceivedIDs adds the "invites_received" edge to the Invite entity by ids.
func (m *UserMutation) AddInvitesReceivedIDs(ids ...int64) {
	if m.invites_received == nil {
		m.invites_received = make(map[int64]struct{})
	}
	for i := range ids {
		m.invites_received[ids[i]] = struct{}{}
	}
}

// ClearInvitesReceived clears the "invites_received" edge to the Invite entity.
func (m *UserMutation) ClearInvitesReceived() {
	m.clearedinvites_received = true
}

// InvitesReceivedCleared reports if the "invites_received" edge to the Invite entity was cleared.
func (m *UserMutation) InvitesReceivedCleared() bool {
	return m.clearedinvites_received
}

// RemoveInvitesReceivedIDs removes the "invites_received" edge to the Invite entity by IDs.
func (m *UserMutation) RemoveInvitesReceivedIDs(ids ...int64) {
	if m.removedinvites_received == nil {
		m.removedinvites_received = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.invites_received, ids[i])
		m.removedinvites_received[ids[i]] = struct{}{}
	}
}

// RemovedInvitesReceived returns the removed IDs of the "invites_received" edge to the Invite entity.
func (m *UserMutation) RemovedInvitesReceivedIDs() (ids []int64) {
	for id := range m.removedinvites_received {
		ids = append(ids, id)
	}
	return
}

// InvitesReceivedIDs returns the "invites_received" edge IDs in the mutation.
func (m *UserMutation) InvitesReceivedIDs() (ids []int64) {
	for id := range m.invites_received {
		ids = append(ids, id)
	}
	return
}

// ResetInvitesReceived resets all changes to the "invites_received" edge.
func (m *UserMutation) ResetInvitesReceived() {
	m.invites_received = nil
	m.clearedinvites_received = false
	m.removedinvites_received = nil
}

// AddTeamInvitationsSentIDs adds the "team_invitations_sent" edge to the TeamInvitation entity by ids.
func (m *UserMutation) AddTeamInvitationsSentIDs(ids ...int64) {
	if m.team_invitations_sent == nil {
		m.team_invitations_sent = make(map[int64]struct{})
	}
	for i := range ids {
		m.team_invitations_sent[ids[i]] = struct{}{}
	}
}

// ClearTeamInvitationsSent clears the "team_invitations_sent" edge to the TeamInvitation entity.
func (m *UserMutation) ClearTeamInvitationsSent() {
	m.clearedteam_invitations_sent = true
}

// TeamInvitationsSentCleared reports if the "team_invitations_sent" edge to the TeamInvitation entity was cleared.
func (m *UserMutation) TeamInvitationsSentCleared() bool {
	return m.clearedteam_invitations_sent
}

// RemoveTeamInvitationsSentIDs removes the "team_invitations_sent" edge to the TeamInvitation entity by IDs.
func (m *UserMutation) RemoveTeamInvitationsSentIDs(ids ...int64) {
	if m.removedteam_invitations_sent == nil {
		m.removedteam_invitations_sent = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.team_invitations_sent, ids[i])
		m.removedteam_invitations_sent[ids[i]] = struct{}{}
	}
}

// RemovedTeamInvitationsSent returns the removed IDs of the "team_invitations_sent" edge to the TeamInvitation entity.
func (m *UserMutation) RemovedTeamInvitationsSentIDs() (ids []int64) {
	for id := range m.removedteam_invitations_sent {
		ids = append(ids, id)
	}
	return
}

// TeamInvitationsSentIDs returns the "team_invitations_sent" edge IDs in the mutation.
func (m *UserMutation) TeamInvitationsSentIDs() (ids []int64) {
	for id := range m.team_invitations_sent {
		ids = append(ids, id)
	}
	return
}

// ResetTeamInvitationsSent resets all changes to the "team_invitations_sent" edge.
func (m *UserMutation) ResetTeamInvitationsSent() {
	m.team_invitations_sent = nil
	m.clearedteam_invitations_sent = false
	m.removedteam_invitations_sent = nil
}

// AddTeamInvitationsReceivedIDs adds the "team_invitations_received" edge to the TeamInvitation entity by ids.
func (m *UserMutation) AddTeamInvitationsReceivedIDs(ids ...int64) {
	if m.team_invitations_received == nil {
		m.team_invitations_received = make(map[int64]struct{})
	}
	for i := range ids {
		m.team_invitations_received[ids[i]] = struct{}{}
	}
}

// ClearTeamInvitationsReceived clears the "team_invitations_received" edge to the TeamInvitation entity.
func (m *UserMutation) ClearTeamInvitationsReceived() {
	m.clearedteam_invitations_received = true
}

// TeamInvitationsReceivedCleared reports if the "team_invitations_received" edge to the TeamInvitation entity was cleared.
func (m *UserMutation) TeamInvitationsReceivedCleared() bool {
	return m.clearedteam_invitations_received
}

// RemoveTeamInvitationsReceivedIDs removes the "team_invitations_received" edge to the TeamInvitation entity by IDs.
func (m *UserMutation) RemoveTeamInvitationsReceivedIDs(ids ...int64) {
	if m.removedteam_invitations_received == nil {
		m.removedteam_invitations_received = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.team_invitations_received, ids[i])
		m.removedteam_invitations_received[ids[i]] = struct{}{}
	}
}

// RemovedTeamInvitationsReceived returns the removed IDs of the "team_invitations_received" edge to the TeamInvitation entity.
func (m *UserMutation) RemovedTeamInvitationsReceivedIDs() (ids []int64) {
	for id := range m.removedteam_invitations_received {
		ids = append(ids, id)
	}
	return
}

// TeamInvitationsReceivedIDs returns the "team_invitations_received" edge IDs in the mutation.
func (m *UserMutation) TeamInvitationsReceivedIDs() (ids []int64) {
	for id := range m.team_invitations_received {
		ids = append(ids, id)
	}
	return
}

// ResetTeamInvitationsReceived resets all changes to the "team_invitations_received" edge.
func (m *UserMutation) ResetTeamInvitationsReceived() {
	m.team_invitations_received = nil
	m.clearedteam_invitations_received = false
	m.removedteam_invitations_received = nil
}

// AddCloudinaryCredentialIDs adds the "cloudinary_credentials" edge to the CloudinaryCredential entity by ids.
func (m *UserMutation) AddCloudinaryCredentialIDs(ids ...int64) {
	if m.cloudinary_credentials == nil {
		m.cloudinary_credentials = make(map[int64]struct{})
	}
	for i := range ids {
		m.cloudinary_credentials[ids[i]] = struct{}{}
	}
}

// ClearCloudinaryCredentials clears the "cloudinary_credentials" edge to the CloudinaryCredential entity.
func (m *UserMutation) ClearCloudinaryCredentials() {
	m.clearedcloudinary_credentials = true
}

// CloudinaryCredentialsCleared reports if the "cloudinary_credentials" edge to the CloudinaryCredential entity was cleared.
func (m *UserMutation) CloudinaryCredentialsCleared() bool {
	return m.clearedcloudinary_credentials
}

// RemoveCloudinaryCredentialIDs removes the "cloudinary_credentials" edge to the CloudinaryCredential entity by IDs.
func (m *UserMutation) RemoveCloudinaryCredentialIDs(ids ...int64) {
	if m.removedcloudinary_credentials == nil {
		m.removedcloudinary_credentials = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.cloudinary_credentials, ids[i])
		m.removedcloudinary_credentials[ids[i]] = struct{}{}
	}
}

// RemovedCloudinaryCredentials returns the removed IDs of the "cloudinary_credentials" edge to the CloudinaryCredential entity.
func (m *UserMutation) RemovedCloudinaryCredentialsIDs() (ids []int64) {
	for id := range m.removedcloudinary_credentials {
		ids = append(ids, id)
	}
	return
}

// CloudinaryCredentialsIDs returns the "cloudinary_credentials" edge IDs in the mutation.
func (m *UserMutation) CloudinaryCredentialsIDs() (ids []int64) {
	for id := range m.cloudinary_credentials {
		ids = append(ids, id)
	}
	return
}

// ResetCloudinaryCredentials resets all changes to the "cloudinary_credentials" edge.
func (m *UserMutation) ResetCloudinaryCredentials() {
	m.cloudinary_credentials = nil
	m.clearedcloudinary_credentials = false
	m.removedcloudinary_credentials = nil
}

// AddTaskAttachmentIDs adds the "task_attachments" edge to the TaskAttachment entity by ids.
func (m *UserMutation) AddTaskAttachmentIDs(ids ...int64) {
	if m.task_attachments == nil {
		m.task_attachments = make(map[int64]struct{})
	}
	for i := range ids {
		m.task_attachments[ids[i]] = struct{}{}
	}
}

// ClearTaskAttachments clears the "task_attachments" edge to the TaskAttachment entity.
func (m *UserMutation) ClearTaskAttachments() {
	m.clearedtask_attachments = true
}

// TaskAttachmentsCleared reports if the "task_attachments" edge to the TaskAttachment entity was cleared.
func (m *UserMutation) TaskAttachmentsCleared() bool {
	return m.clearedtask_attachments
}

// RemoveTaskAttachmentIDs removes the "task_attachments" edge to the TaskAttachment entity by IDs.
func (m *UserMutation) RemoveTaskAttachmentIDs(ids ...int64) {
	if m.removedtask_attachments == nil {
		m.removedtask_attachments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.task_attachments, ids[i])
		m.removedtask_attachments[ids[i]] = struct{}{}
	}
}

// RemovedTaskAttachments returns the removed IDs of the "task_attachments" edge to the TaskAttachment entity.
func (m *UserMutation) RemovedTaskAttachmentsIDs() (ids []int64) {
	for id := range m.removedtask_attachments {
		ids = append(ids, id)
	}
	return
}

// TaskAttachmentsIDs returns the "task_attachments" edge IDs in the mutation.
func (m *UserMutation) TaskAttachmentsIDs() (ids []int64) {
	for id := range m.task_attachments {
		ids = append(ids, id)
	}
	return
}

// ResetTaskAttachments resets all changes to the "task_attachments" edge.
func (m *UserMutation) ResetTaskAttachments() {
	m.task_attachments = nil
	m.clearedtask_attachments = false
	m.removedtask_attachments = nil
}

// AddWikiPagesCreatedIDs adds the "wiki_pages_created" edge to the WikiPage entity by ids.
func (m *UserMutation) AddWikiPagesCreatedIDs(ids ...int64) {
	if m.wiki_pages_created == nil {
		m.wiki_pages_created = make(map[int64]struct{})
	}
	for i := range ids {
		m.wiki_pages_created[ids[i]] = struct{}{}
	}
}

// ClearWikiPagesCreated clears the "wiki_pages_created" edge to the WikiPage entity.
func (m *UserMutation) ClearWikiPagesCreated() {
	m.clearedwiki_pages_created = true
}

// WikiPagesCreatedCleared reports if the "wiki_pages_created" edge to the WikiPage entity was cleared.
func (m *UserMutation) WikiPagesCreatedCleared() bool {
	return m.clearedwiki_pages_created
}

// RemoveWikiPagesCreatedIDs removes the "wiki_pages_created" edge to the WikiPage entity by IDs.
func (m *UserMutation) RemoveWikiPagesCreatedIDs(ids ...int64) {
	if m.removedwiki_pages_created == nil {
		m.removedwiki_pages_created = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.wiki_pages_created, ids[i])
		m.removedwiki_pages_created[ids[i]] = struct{}{}
	}
}

// RemovedWikiPagesCreated returns the removed IDs of the "wiki_pages_created" edge to the WikiPage entity.
func (m *UserMutation) RemovedWikiPagesCreatedIDs() (ids []int64) {
	for id := range m.removedwiki_pages_created {
		ids = append(ids, id)
	}
	return
}

// WikiPagesCreatedIDs returns the "wiki_pages_created" edge IDs in the mutation.
func (m *UserMutation) WikiPagesCreatedIDs() (ids []int64) {
	for id := range m.wiki_pages_created {
		ids = append(ids, id)
	}
	return
}

// ResetWikiPagesCreated resets all changes to the "wiki_pages_created" edge.
func (m *UserMutation) ResetWikiPagesCreated() {
	m.wiki_pages_created = nil
	m.clearedwiki_pages_created = false
	m.removedwiki_pages_created = nil
}

// AddYjsUpdateIDs adds the "yjs_updates" edge to the YjsUpdate entity by ids.
func (m *UserMutation) AddYjsUpdateIDs(ids ...int64) {
	if m.yjs_updates == nil {
		m.yjs_updates = make(map[int64]struct{})
	}
	for i := range ids {
		m.yjs_updates[ids[i]] = struct{}{}
	}
}

// ClearYjsUpdates clears the "yjs_updates" edge to the YjsUpdate entity.
func (m *UserMutation) ClearYjsUpdates() {
	m.clearedyjs_updates = true
}

// YjsUpdatesCleared reports if the "yjs_updates" edge to the YjsUpdate entity was cleared.
func (m *UserMutation) YjsUpdatesCleared() bool {
	return m.clearedyjs_updates
}

// RemoveYjsUpdateIDs removes the "yjs_updates" edge to the YjsUpdate entity by IDs.
func (m *UserMutation) RemoveYjsUpdateIDs(ids ...int64) {
	if m.removedyjs_updates == nil {
		m.removedyjs_updates = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.yjs_updates, ids[i])
		m.removedyjs_updates[ids[i]] = struct{}{}
	}
}

// RemovedYjsUpdates returns the removed IDs of the "yjs_updates" edge to the YjsUpdate entity.
func (m *UserMutation) RemovedYjsUpdatesIDs() (ids []int64) {
	for id := range m.removedyjs_updates {
		ids = append(ids, id)
	}
	return
}

// YjsUpdatesIDs returns the "yjs_updates" edge IDs in the mutation.
func (m *UserMutation) YjsUpdatesIDs() (ids []int64) {
	for id := range m.yjs_updates {
		ids = append(ids, id)
	}
	return
}

// ResetYjsUpdates resets all changes to the "yjs_updates" edge.
func (m *UserMutation) ResetYjsUpdates() {
	m.yjs_updates = nil
	m.clearedyjs_updates = false
	m.removedyjs_updates = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.is_admin != nil {
		fields = append(fields, user.FieldIsAdmin)
	}
	if m.totp_secret != nil {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.backup_codes != nil {
		fields = append(fields, user.FieldBackupCodes)
	}
	if m.password_changed_at != nil {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	if m.invite_count != nil {
		fields = append(fields, user.FieldInviteCount)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldName:
		return m.Name()
	case user.FieldIsAdmin:
		return m.IsAdmin()
	case user.FieldTotpSecret:
		return m.TotpSecret()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldBackupCodes:
		return m.BackupCodes()
	case user.FieldPasswordChangedAt:
		return m.PasswordChangedAt()
	case user.FieldInviteCount:
		return m.InviteCount()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldIsAdmin:
		return m.OldIsAdmin(ctx)
	case user.FieldTotpSecret:
		return m.OldTotpSecret(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldBackupCodes:
		return m.OldBackupCodes(ctx)
	case user.FieldPasswordChangedAt:
		return m.OldPasswordChangedAt(ctx)
	case user.FieldInviteCount:
		return m.OldInviteCount(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldIsAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAdmin(v)
		return nil
	case user.FieldTotpSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecret(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldBackupCodes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackupCodes(v)
		return nil
	case user.FieldPasswordChangedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordChangedAt(v)
		return nil
	case user.FieldInviteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteCount(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addinvite_count != nil {
		fields = append(fields, user.FieldInviteCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldInviteCount:
		return m.AddedInviteCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldInviteCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInviteCount(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldTotpSecret) {
		fields = append(fields, user.FieldTotpSecret)
	}
	if m.FieldCleared(user.FieldBackupCodes) {
		fields = append(fields, user.FieldBackupCodes)
	}
	if m.FieldCleared(user.FieldPasswordChangedAt) {
		fields = append(fields, user.FieldPasswordChangedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldTotpSecret:
		m.ClearTotpSecret()
		return nil
	case user.FieldBackupCodes:
		m.ClearBackupCodes()
		return nil
	case user.FieldPasswordChangedAt:
		m.ClearPasswordChangedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldIsAdmin:
		m.ResetIsAdmin()
		return nil
	case user.FieldTotpSecret:
		m.ResetTotpSecret()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldBackupCodes:
		m.ResetBackupCodes()
		return nil
	case user.FieldPasswordChangedAt:
		m.ResetPasswordChangedAt()
		return nil
	case user.FieldInviteCount:
		m.ResetInviteCount()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 19)
	if m.owned_projects != nil {
		edges = append(edges, user.EdgeOwnedProjects)
	}
	if m.owned_teams != nil {
		edges = append(edges, user.EdgeOwnedTeams)
	}
	if m.team_memberships != nil {
		edges = append(edges, user.EdgeTeamMemberships)
	}
	if m.project_memberships != nil {
		edges = append(edges, user.EdgeProjectMemberships)
	}
	if m.project_memberships_granted != nil {
		edges = append(edges, user.EdgeProjectMembershipsGranted)
	}
	if m.tasks_assigned != nil {
		edges = append(edges, user.EdgeTasksAssigned)
	}
	if m.sprints != nil {
		edges = append(edges, user.EdgeSprints)
	}
	if m.tags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.user_activities != nil {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.task_comments != nil {
		edges = append(edges, user.EdgeTaskComments)
	}
	if m.invites_sent != nil {
		edges = append(edges, user.EdgeInvitesSent)
	}
	if m.invites_received != nil {
		edges = append(edges, user.EdgeInvitesReceived)
	}
	if m.team_invitations_sent != nil {
		edges = append(edges, user.EdgeTeamInvitationsSent)
	}
	if m.team_invitations_received != nil {
		edges = append(edges, user.EdgeTeamInvitationsReceived)
	}
	if m.cloudinary_credentials != nil {
		edges = append(edges, user.EdgeCloudinaryCredentials)
	}
	if m.task_attachments != nil {
		edges = append(edges, user.EdgeTaskAttachments)
	}
	if m.wiki_pages_created != nil {
		edges = append(edges, user.EdgeWikiPagesCreated)
	}
	if m.yjs_updates != nil {
		edges = append(edges, user.EdgeYjsUpdates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwnedProjects:
		ids := make([]ent.Value, 0, len(m.owned_projects))
		for id := range m.owned_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedTeams:
		ids := make([]ent.Value, 0, len(m.owned_teams))
		for id := range m.owned_teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamMemberships:
		ids := make([]ent.Value, 0, len(m.team_memberships))
		for id := range m.team_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectMemberships:
		ids := make([]ent.Value, 0, len(m.project_memberships))
		for id := range m.project_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectMembershipsGranted:
		ids := make([]ent.Value, 0, len(m.project_memberships_granted))
		for id := range m.project_memberships_granted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTasksAssigned:
		ids := make([]ent.Value, 0, len(m.tasks_assigned))
		for id := range m.tasks_assigned {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSprints:
		ids := make([]ent.Value, 0, len(m.sprints))
		for id := range m.sprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.user_activities))
		for id := range m.user_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTaskComments:
		ids := make([]ent.Value, 0, len(m.task_comments))
		for id := range m.task_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitesSent:
		ids := make([]ent.Value, 0, len(m.invites_sent))
		for id := range m.invites_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitesReceived:
		ids := make([]ent.Value, 0, len(m.invites_received))
		for id := range m.invites_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamInvitationsSent:
		ids := make([]ent.Value, 0, len(m.team_invitations_sent))
		for id := range m.team_invitations_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamInvitationsReceived:
		ids := make([]ent.Value, 0, len(m.team_invitations_received))
		for id := range m.team_invitations_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCloudinaryCredentials:
		ids := make([]ent.Value, 0, len(m.cloudinary_credentials))
		for id := range m.cloudinary_credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTaskAttachments:
		ids := make([]ent.Value, 0, len(m.task_attachments))
		for id := range m.task_attachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWikiPagesCreated:
		ids := make([]ent.Value, 0, len(m.wiki_pages_created))
		for id := range m.wiki_pages_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeYjsUpdates:
		ids := make([]ent.Value, 0, len(m.yjs_updates))
		for id := range m.yjs_updates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 19)
	if m.removedowned_projects != nil {
		edges = append(edges, user.EdgeOwnedProjects)
	}
	if m.removedowned_teams != nil {
		edges = append(edges, user.EdgeOwnedTeams)
	}
	if m.removedteam_memberships != nil {
		edges = append(edges, user.EdgeTeamMemberships)
	}
	if m.removedproject_memberships != nil {
		edges = append(edges, user.EdgeProjectMemberships)
	}
	if m.removedproject_memberships_granted != nil {
		edges = append(edges, user.EdgeProjectMembershipsGranted)
	}
	if m.removedtasks_assigned != nil {
		edges = append(edges, user.EdgeTasksAssigned)
	}
	if m.removedsprints != nil {
		edges = append(edges, user.EdgeSprints)
	}
	if m.removedtags != nil {
		edges = append(edges, user.EdgeTags)
	}
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removeduser_activities != nil {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.removedtask_comments != nil {
		edges = append(edges, user.EdgeTaskComments)
	}
	if m.removedinvites_sent != nil {
		edges = append(edges, user.EdgeInvitesSent)
	}
	if m.removedinvites_received != nil {
		edges = append(edges, user.EdgeInvitesReceived)
	}
	if m.removedteam_invitations_sent != nil {
		edges = append(edges, user.EdgeTeamInvitationsSent)
	}
	if m.removedteam_invitations_received != nil {
		edges = append(edges, user.EdgeTeamInvitationsReceived)
	}
	if m.removedcloudinary_credentials != nil {
		edges = append(edges, user.EdgeCloudinaryCredentials)
	}
	if m.removedtask_attachments != nil {
		edges = append(edges, user.EdgeTaskAttachments)
	}
	if m.removedwiki_pages_created != nil {
		edges = append(edges, user.EdgeWikiPagesCreated)
	}
	if m.removedyjs_updates != nil {
		edges = append(edges, user.EdgeYjsUpdates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOwnedProjects:
		ids := make([]ent.Value, 0, len(m.removedowned_projects))
		for id := range m.removedowned_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOwnedTeams:
		ids := make([]ent.Value, 0, len(m.removedowned_teams))
		for id := range m.removedowned_teams {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamMemberships:
		ids := make([]ent.Value, 0, len(m.removedteam_memberships))
		for id := range m.removedteam_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectMemberships:
		ids := make([]ent.Value, 0, len(m.removedproject_memberships))
		for id := range m.removedproject_memberships {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProjectMembershipsGranted:
		ids := make([]ent.Value, 0, len(m.removedproject_memberships_granted))
		for id := range m.removedproject_memberships_granted {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTasksAssigned:
		ids := make([]ent.Value, 0, len(m.removedtasks_assigned))
		for id := range m.removedtasks_assigned {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSprints:
		ids := make([]ent.Value, 0, len(m.removedsprints))
		for id := range m.removedsprints {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.removeduser_activities))
		for id := range m.removeduser_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTaskComments:
		ids := make([]ent.Value, 0, len(m.removedtask_comments))
		for id := range m.removedtask_comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitesSent:
		ids := make([]ent.Value, 0, len(m.removedinvites_sent))
		for id := range m.removedinvites_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInvitesReceived:
		ids := make([]ent.Value, 0, len(m.removedinvites_received))
		for id := range m.removedinvites_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamInvitationsSent:
		ids := make([]ent.Value, 0, len(m.removedteam_invitations_sent))
		for id := range m.removedteam_invitations_sent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTeamInvitationsReceived:
		ids := make([]ent.Value, 0, len(m.removedteam_invitations_received))
		for id := range m.removedteam_invitations_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCloudinaryCredentials:
		ids := make([]ent.Value, 0, len(m.removedcloudinary_credentials))
		for id := range m.removedcloudinary_credentials {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTaskAttachments:
		ids := make([]ent.Value, 0, len(m.removedtask_attachments))
		for id := range m.removedtask_attachments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWikiPagesCreated:
		ids := make([]ent.Value, 0, len(m.removedwiki_pages_created))
		for id := range m.removedwiki_pages_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeYjsUpdates:
		ids := make([]ent.Value, 0, len(m.removedyjs_updates))
		for id := range m.removedyjs_updates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 19)
	if m.clearedowned_projects {
		edges = append(edges, user.EdgeOwnedProjects)
	}
	if m.clearedowned_teams {
		edges = append(edges, user.EdgeOwnedTeams)
	}
	if m.clearedteam_memberships {
		edges = append(edges, user.EdgeTeamMemberships)
	}
	if m.clearedproject_memberships {
		edges = append(edges, user.EdgeProjectMemberships)
	}
	if m.clearedproject_memberships_granted {
		edges = append(edges, user.EdgeProjectMembershipsGranted)
	}
	if m.clearedtasks_assigned {
		edges = append(edges, user.EdgeTasksAssigned)
	}
	if m.clearedsprints {
		edges = append(edges, user.EdgeSprints)
	}
	if m.clearedtags {
		edges = append(edges, user.EdgeTags)
	}
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.cleareduser_activities {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.clearedtask_comments {
		edges = append(edges, user.EdgeTaskComments)
	}
	if m.clearedinvites_sent {
		edges = append(edges, user.EdgeInvitesSent)
	}
	if m.clearedinvites_received {
		edges = append(edges, user.EdgeInvitesReceived)
	}
	if m.clearedteam_invitations_sent {
		edges = append(edges, user.EdgeTeamInvitationsSent)
	}
	if m.clearedteam_invitations_received {
		edges = append(edges, user.EdgeTeamInvitationsReceived)
	}
	if m.clearedcloudinary_credentials {
		edges = append(edges, user.EdgeCloudinaryCredentials)
	}
	if m.clearedtask_attachments {
		edges = append(edges, user.EdgeTaskAttachments)
	}
	if m.clearedwiki_pages_created {
		edges = append(edges, user.EdgeWikiPagesCreated)
	}
	if m.clearedyjs_updates {
		edges = append(edges, user.EdgeYjsUpdates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOwnedProjects:
		return m.clearedowned_projects
	case user.EdgeOwnedTeams:
		return m.clearedowned_teams
	case user.EdgeTeamMemberships:
		return m.clearedteam_memberships
	case user.EdgeProjectMemberships:
		return m.clearedproject_memberships
	case user.EdgeProjectMembershipsGranted:
		return m.clearedproject_memberships_granted
	case user.EdgeTasksAssigned:
		return m.clearedtasks_assigned
	case user.EdgeSprints:
		return m.clearedsprints
	case user.EdgeTags:
		return m.clearedtags
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeUserActivities:
		return m.cleareduser_activities
	case user.EdgeTaskComments:
		return m.clearedtask_comments
	case user.EdgeInvitesSent:
		return m.clearedinvites_sent
	case user.EdgeInvitesReceived:
		return m.clearedinvites_received
	case user.EdgeTeamInvitationsSent:
		return m.clearedteam_invitations_sent
	case user.EdgeTeamInvitationsReceived:
		return m.clearedteam_invitations_received
	case user.EdgeCloudinaryCredentials:
		return m.clearedcloudinary_credentials
	case user.EdgeTaskAttachments:
		return m.clearedtask_attachments
	case user.EdgeWikiPagesCreated:
		return m.clearedwiki_pages_created
	case user.EdgeYjsUpdates:
		return m.clearedyjs_updates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOwnedProjects:
		m.ResetOwnedProjects()
		return nil
	case user.EdgeOwnedTeams:
		m.ResetOwnedTeams()
		return nil
	case user.EdgeTeamMemberships:
		m.ResetTeamMemberships()
		return nil
	case user.EdgeProjectMemberships:
		m.ResetProjectMemberships()
		return nil
	case user.EdgeProjectMembershipsGranted:
		m.ResetProjectMembershipsGranted()
		return nil
	case user.EdgeTasksAssigned:
		m.ResetTasksAssigned()
		return nil
	case user.EdgeSprints:
		m.ResetSprints()
		return nil
	case user.EdgeTags:
		m.ResetTags()
		return nil
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeUserActivities:
		m.ResetUserActivities()
		return nil
	case user.EdgeTaskComments:
		m.ResetTaskComments()
		return nil
	case user.EdgeInvitesSent:
		m.ResetInvitesSent()
		return nil
	case user.EdgeInvitesReceived:
		m.ResetInvitesReceived()
		return nil
	case user.EdgeTeamInvitationsSent:
		m.ResetTeamInvitationsSent()
		return nil
	case user.EdgeTeamInvitationsReceived:
		m.ResetTeamInvitationsReceived()
		return nil
	case user.EdgeCloudinaryCredentials:
		m.ResetCloudinaryCredentials()
		return nil
	case user.EdgeTaskAttachments:
		m.ResetTaskAttachments()
		return nil
	case user.EdgeWikiPagesCreated:
		m.ResetWikiPagesCreated()
		return nil
	case user.EdgeYjsUpdates:
		m.ResetYjsUpdates()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserActivityMutation represents an operation that mutates the UserActivity nodes in the graph.
type UserActivityMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	activity_type *string
	ip_address    *string
	user_agent    *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserActivity, error)
	predicates    []predicate.UserActivity
}

var _ ent.Mutation = (*UserActivityMutation)(nil)

// useractivityOption allows management of the mutation configuration using functional options.
type useractivityOption func(*UserActivityMutation)

// newUserActivityMutation creates new mutation for the UserActivity entity.
func newUserActivityMutation(c config, op Op, opts ...useractivityOption) *UserActivityMutation {
	m := &UserActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserActivityID sets the ID field of the mutation.
func withUserActivityID(id int64) useractivityOption {
	return func(m *UserActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserActivity
		)
		m.oldValue = func(ctx context.Context) (*UserActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserActivity sets the old UserActivity of the mutation.
func withUserActivity(node *UserActivity) useractivityOption {
	return func(m *UserActivityMutation) {
		m.oldValue = func(context.Context) (*UserActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserActivity entities.
func (m *UserActivityMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserActivityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserActivityMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserActivityMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserActivityMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserActivityMutation) ResetUserID() {
	m.user = nil
}

// SetActivityType sets the "activity_type" field.
func (m *UserActivityMutation) SetActivityType(s string) {
	m.activity_type = &s
}

// ActivityType returns the value of the "activity_type" field in the mutation.
func (m *UserActivityMutation) ActivityType() (r string, exists bool) {
	v := m.activity_type
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityType returns the old "activity_type" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldActivityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityType: %w", err)
	}
	return oldValue.ActivityType, nil
}

// ResetActivityType resets all changes to the "activity_type" field.
func (m *UserActivityMutation) ResetActivityType() {
	m.activity_type = nil
}

// SetIPAddress sets the "ip_address" field.
func (m *UserActivityMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UserActivityMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UserActivityMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[useractivity.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UserActivityMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UserActivityMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, useractivity.FieldIPAddress)
}

// SetUserAgent sets the "user_agent" field.
func (m *UserActivityMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UserActivityMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UserActivityMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[useractivity.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UserActivityMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UserActivityMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, useractivity.FieldUserAgent)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserActivityMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[useractivity.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserActivityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserActivityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserActivityMutation builder.
func (m *UserActivityMutation) Where(ps ...predicate.UserActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserActivity).
func (m *UserActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserActivityMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.user != nil {
		fields = append(fields, useractivity.FieldUserID)
	}
	if m.activity_type != nil {
		fields = append(fields, useractivity.FieldActivityType)
	}
	if m.ip_address != nil {
		fields = append(fields, useractivity.FieldIPAddress)
	}
	if m.user_agent != nil {
		fields = append(fields, useractivity.FieldUserAgent)
	}
	if m.created_at != nil {
		fields = append(fields, useractivity.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useractivity.FieldUserID:
		return m.UserID()
	case useractivity.FieldActivityType:
		return m.ActivityType()
	case useractivity.FieldIPAddress:
		return m.IPAddress()
	case useractivity.FieldUserAgent:
		return m.UserAgent()
	case useractivity.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useractivity.FieldUserID:
		return m.OldUserID(ctx)
	case useractivity.FieldActivityType:
		return m.OldActivityType(ctx)
	case useractivity.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case useractivity.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case useractivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useractivity.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case useractivity.FieldActivityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityType(v)
		return nil
	case useractivity.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case useractivity.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case useractivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserActivityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useractivity.FieldIPAddress) {
		fields = append(fields, useractivity.FieldIPAddress)
	}
	if m.FieldCleared(useractivity.FieldUserAgent) {
		fields = append(fields, useractivity.FieldUserAgent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserActivityMutation) ClearField(name string) error {
	switch name {
	case useractivity.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case useractivity.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	}
	return fmt.Errorf("unknown UserActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserActivityMutation) ResetField(name string) error {
	switch name {
	case useractivity.FieldUserID:
		m.ResetUserID()
		return nil
	case useractivity.FieldActivityType:
		m.ResetActivityType()
		return nil
	case useractivity.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case useractivity.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case useractivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useractivity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, useractivity.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case useractivity.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserActivityMutation) ClearEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserActivityMutation) ResetEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserActivity edge %s", name)
}

// WikiBlockMutation represents an operation that mutates the WikiBlock nodes in the graph.
type WikiBlockMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	block_type     *string
	level          *int
	addlevel       *int
	headings_path  *string
	canonical_json *string
	plain_text     *string
	position       *int
	addposition    *int
	search_text    *string
	clearedFields  map[string]struct{}
	page           *int64
	clearedpage    bool
	done           bool
	oldValue       func(context.Context) (*WikiBlock, error)
	predicates     []predicate.WikiBlock
}

var _ ent.Mutation = (*WikiBlockMutation)(nil)

// wikiblockOption allows management of the mutation configuration using functional options.
type wikiblockOption func(*WikiBlockMutation)

// newWikiBlockMutation creates new mutation for the WikiBlock entity.
func newWikiBlockMutation(c config, op Op, opts ...wikiblockOption) *WikiBlockMutation {
	m := &WikiBlockMutation{
		config:        c,
		op:            op,
		typ:           TypeWikiBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWikiBlockID sets the ID field of the mutation.
func withWikiBlockID(id int64) wikiblockOption {
	return func(m *WikiBlockMutation) {
		var (
			err   error
			once  sync.Once
			value *WikiBlock
		)
		m.oldValue = func(ctx context.Context) (*WikiBlock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WikiBlock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWikiBlock sets the old WikiBlock of the mutation.
func withWikiBlock(node *WikiBlock) wikiblockOption {
	return func(m *WikiBlockMutation) {
		m.oldValue = func(context.Context) (*WikiBlock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WikiBlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WikiBlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WikiBlock entities.
func (m *WikiBlockMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WikiBlockMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WikiBlockMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WikiBlock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPageID sets the "page_id" field.
func (m *WikiBlockMutation) SetPageID(i int64) {
	m.page = &i
}

// PageID returns the value of the "page_id" field in the mutation.
func (m *WikiBlockMutation) PageID() (r int64, exists bool) {
	v := m.page
	if v == nil {
		return
	}
	return *v, true
}

// OldPageID returns the old "page_id" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldPageID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageID: %w", err)
	}
	return oldValue.PageID, nil
}

// ResetPageID resets all changes to the "page_id" field.
func (m *WikiBlockMutation) ResetPageID() {
	m.page = nil
}

// SetBlockType sets the "block_type" field.
func (m *WikiBlockMutation) SetBlockType(s string) {
	m.block_type = &s
}

// BlockType returns the value of the "block_type" field in the mutation.
func (m *WikiBlockMutation) BlockType() (r string, exists bool) {
	v := m.block_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockType returns the old "block_type" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldBlockType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockType: %w", err)
	}
	return oldValue.BlockType, nil
}

// ResetBlockType resets all changes to the "block_type" field.
func (m *WikiBlockMutation) ResetBlockType() {
	m.block_type = nil
}

// SetLevel sets the "level" field.
func (m *WikiBlockMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *WikiBlockMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldLevel(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *WikiBlockMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *WikiBlockMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ClearLevel clears the value of the "level" field.
func (m *WikiBlockMutation) ClearLevel() {
	m.level = nil
	m.addlevel = nil
	m.clearedFields[wikiblock.FieldLevel] = struct{}{}
}

// LevelCleared returns if the "level" field was cleared in this mutation.
func (m *WikiBlockMutation) LevelCleared() bool {
	_, ok := m.clearedFields[wikiblock.FieldLevel]
	return ok
}

// ResetLevel resets all changes to the "level" field.
func (m *WikiBlockMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
	delete(m.clearedFields, wikiblock.FieldLevel)
}

// SetHeadingsPath sets the "headings_path" field.
func (m *WikiBlockMutation) SetHeadingsPath(s string) {
	m.headings_path = &s
}

// HeadingsPath returns the value of the "headings_path" field in the mutation.
func (m *WikiBlockMutation) HeadingsPath() (r string, exists bool) {
	v := m.headings_path
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadingsPath returns the old "headings_path" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldHeadingsPath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadingsPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadingsPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadingsPath: %w", err)
	}
	return oldValue.HeadingsPath, nil
}

// ClearHeadingsPath clears the value of the "headings_path" field.
func (m *WikiBlockMutation) ClearHeadingsPath() {
	m.headings_path = nil
	m.clearedFields[wikiblock.FieldHeadingsPath] = struct{}{}
}

// HeadingsPathCleared returns if the "headings_path" field was cleared in this mutation.
func (m *WikiBlockMutation) HeadingsPathCleared() bool {
	_, ok := m.clearedFields[wikiblock.FieldHeadingsPath]
	return ok
}

// ResetHeadingsPath resets all changes to the "headings_path" field.
func (m *WikiBlockMutation) ResetHeadingsPath() {
	m.headings_path = nil
	delete(m.clearedFields, wikiblock.FieldHeadingsPath)
}

// SetCanonicalJSON sets the "canonical_json" field.
func (m *WikiBlockMutation) SetCanonicalJSON(s string) {
	m.canonical_json = &s
}

// CanonicalJSON returns the value of the "canonical_json" field in the mutation.
func (m *WikiBlockMutation) CanonicalJSON() (r string, exists bool) {
	v := m.canonical_json
	if v == nil {
		return
	}
	return *v, true
}

// OldCanonicalJSON returns the old "canonical_json" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldCanonicalJSON(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanonicalJSON is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanonicalJSON requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanonicalJSON: %w", err)
	}
	return oldValue.CanonicalJSON, nil
}

// ClearCanonicalJSON clears the value of the "canonical_json" field.
func (m *WikiBlockMutation) ClearCanonicalJSON() {
	m.canonical_json = nil
	m.clearedFields[wikiblock.FieldCanonicalJSON] = struct{}{}
}

// CanonicalJSONCleared returns if the "canonical_json" field was cleared in this mutation.
func (m *WikiBlockMutation) CanonicalJSONCleared() bool {
	_, ok := m.clearedFields[wikiblock.FieldCanonicalJSON]
	return ok
}

// ResetCanonicalJSON resets all changes to the "canonical_json" field.
func (m *WikiBlockMutation) ResetCanonicalJSON() {
	m.canonical_json = nil
	delete(m.clearedFields, wikiblock.FieldCanonicalJSON)
}

// SetPlainText sets the "plain_text" field.
func (m *WikiBlockMutation) SetPlainText(s string) {
	m.plain_text = &s
}

// PlainText returns the value of the "plain_text" field in the mutation.
func (m *WikiBlockMutation) PlainText() (r string, exists bool) {
	v := m.plain_text
	if v == nil {
		return
	}
	return *v, true
}

// OldPlainText returns the old "plain_text" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldPlainText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlainText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlainText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlainText: %w", err)
	}
	return oldValue.PlainText, nil
}

// ClearPlainText clears the value of the "plain_text" field.
func (m *WikiBlockMutation) ClearPlainText() {
	m.plain_text = nil
	m.clearedFields[wikiblock.FieldPlainText] = struct{}{}
}

// PlainTextCleared returns if the "plain_text" field was cleared in this mutation.
func (m *WikiBlockMutation) PlainTextCleared() bool {
	_, ok := m.clearedFields[wikiblock.FieldPlainText]
	return ok
}

// ResetPlainText resets all changes to the "plain_text" field.
func (m *WikiBlockMutation) ResetPlainText() {
	m.plain_text = nil
	delete(m.clearedFields, wikiblock.FieldPlainText)
}

// SetPosition sets the "position" field.
func (m *WikiBlockMutation) SetPosition(i int) {
	m.position = &i
	m.addposition = nil
}

// Position returns the value of the "position" field in the mutation.
func (m *WikiBlockMutation) Position() (r int, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldPosition(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// AddPosition adds i to the "position" field.
func (m *WikiBlockMutation) AddPosition(i int) {
	if m.addposition != nil {
		*m.addposition += i
	} else {
		m.addposition = &i
	}
}

// AddedPosition returns the value that was added to the "position" field in this mutation.
func (m *WikiBlockMutation) AddedPosition() (r int, exists bool) {
	v := m.addposition
	if v == nil {
		return
	}
	return *v, true
}

// ResetPosition resets all changes to the "position" field.
func (m *WikiBlockMutation) ResetPosition() {
	m.position = nil
	m.addposition = nil
}

// SetSearchText sets the "search_text" field.
func (m *WikiBlockMutation) SetSearchText(s string) {
	m.search_text = &s
}

// SearchText returns the value of the "search_text" field in the mutation.
func (m *WikiBlockMutation) SearchText() (r string, exists bool) {
	v := m.search_text
	if v == nil {
		return
	}
	return *v, true
}

// OldSearchText returns the old "search_text" field's value of the WikiBlock entity.
// If the WikiBlock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiBlockMutation) OldSearchText(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSearchText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSearchText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSearchText: %w", err)
	}
	return oldValue.SearchText, nil
}

// ClearSearchText clears the value of the "search_text" field.
func (m *WikiBlockMutation) ClearSearchText() {
	m.search_text = nil
	m.clearedFields[wikiblock.FieldSearchText] = struct{}{}
}

// SearchTextCleared returns if the "search_text" field was cleared in this mutation.
func (m *WikiBlockMutation) SearchTextCleared() bool {
	_, ok := m.clearedFields[wikiblock.FieldSearchText]
	return ok
}

// ResetSearchText resets all changes to the "search_text" field.
func (m *WikiBlockMutation) ResetSearchText() {
	m.search_text = nil
	delete(m.clearedFields, wikiblock.FieldSearchText)
}

// ClearPage clears the "page" edge to the WikiPage entity.
func (m *WikiBlockMutation) ClearPage() {
	m.clearedpage = true
	m.clearedFields[wikiblock.FieldPageID] = struct{}{}
}

// PageCleared reports if the "page" edge to the WikiPage entity was cleared.
func (m *WikiBlockMutation) PageCleared() bool {
	return m.clearedpage
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *WikiBlockMutation) PageIDs() (ids []int64) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *WikiBlockMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// Where appends a list predicates to the WikiBlockMutation builder.
func (m *WikiBlockMutation) Where(ps ...predicate.WikiBlock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WikiBlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WikiBlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WikiBlock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WikiBlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WikiBlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WikiBlock).
func (m *WikiBlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WikiBlockMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.page != nil {
		fields = append(fields, wikiblock.FieldPageID)
	}
	if m.block_type != nil {
		fields = append(fields, wikiblock.FieldBlockType)
	}
	if m.level != nil {
		fields = append(fields, wikiblock.FieldLevel)
	}
	if m.headings_path != nil {
		fields = append(fields, wikiblock.FieldHeadingsPath)
	}
	if m.canonical_json != nil {
		fields = append(fields, wikiblock.FieldCanonicalJSON)
	}
	if m.plain_text != nil {
		fields = append(fields, wikiblock.FieldPlainText)
	}
	if m.position != nil {
		fields = append(fields, wikiblock.FieldPosition)
	}
	if m.search_text != nil {
		fields = append(fields, wikiblock.FieldSearchText)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WikiBlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wikiblock.FieldPageID:
		return m.PageID()
	case wikiblock.FieldBlockType:
		return m.BlockType()
	case wikiblock.FieldLevel:
		return m.Level()
	case wikiblock.FieldHeadingsPath:
		return m.HeadingsPath()
	case wikiblock.FieldCanonicalJSON:
		return m.CanonicalJSON()
	case wikiblock.FieldPlainText:
		return m.PlainText()
	case wikiblock.FieldPosition:
		return m.Position()
	case wikiblock.FieldSearchText:
		return m.SearchText()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WikiBlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wikiblock.FieldPageID:
		return m.OldPageID(ctx)
	case wikiblock.FieldBlockType:
		return m.OldBlockType(ctx)
	case wikiblock.FieldLevel:
		return m.OldLevel(ctx)
	case wikiblock.FieldHeadingsPath:
		return m.OldHeadingsPath(ctx)
	case wikiblock.FieldCanonicalJSON:
		return m.OldCanonicalJSON(ctx)
	case wikiblock.FieldPlainText:
		return m.OldPlainText(ctx)
	case wikiblock.FieldPosition:
		return m.OldPosition(ctx)
	case wikiblock.FieldSearchText:
		return m.OldSearchText(ctx)
	}
	return nil, fmt.Errorf("unknown WikiBlock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WikiBlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wikiblock.FieldPageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageID(v)
		return nil
	case wikiblock.FieldBlockType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockType(v)
		return nil
	case wikiblock.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case wikiblock.FieldHeadingsPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadingsPath(v)
		return nil
	case wikiblock.FieldCanonicalJSON:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanonicalJSON(v)
		return nil
	case wikiblock.FieldPlainText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlainText(v)
		return nil
	case wikiblock.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case wikiblock.FieldSearchText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSearchText(v)
		return nil
	}
	return fmt.Errorf("unknown WikiBlock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WikiBlockMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, wikiblock.FieldLevel)
	}
	if m.addposition != nil {
		fields = append(fields, wikiblock.FieldPosition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WikiBlockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case wikiblock.FieldLevel:
		return m.AddedLevel()
	case wikiblock.FieldPosition:
		return m.AddedPosition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WikiBlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case wikiblock.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case wikiblock.FieldPosition:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPosition(v)
		return nil
	}
	return fmt.Errorf("unknown WikiBlock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WikiBlockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(wikiblock.FieldLevel) {
		fields = append(fields, wikiblock.FieldLevel)
	}
	if m.FieldCleared(wikiblock.FieldHeadingsPath) {
		fields = append(fields, wikiblock.FieldHeadingsPath)
	}
	if m.FieldCleared(wikiblock.FieldCanonicalJSON) {
		fields = append(fields, wikiblock.FieldCanonicalJSON)
	}
	if m.FieldCleared(wikiblock.FieldPlainText) {
		fields = append(fields, wikiblock.FieldPlainText)
	}
	if m.FieldCleared(wikiblock.FieldSearchText) {
		fields = append(fields, wikiblock.FieldSearchText)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WikiBlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WikiBlockMutation) ClearField(name string) error {
	switch name {
	case wikiblock.FieldLevel:
		m.ClearLevel()
		return nil
	case wikiblock.FieldHeadingsPath:
		m.ClearHeadingsPath()
		return nil
	case wikiblock.FieldCanonicalJSON:
		m.ClearCanonicalJSON()
		return nil
	case wikiblock.FieldPlainText:
		m.ClearPlainText()
		return nil
	case wikiblock.FieldSearchText:
		m.ClearSearchText()
		return nil
	}
	return fmt.Errorf("unknown WikiBlock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WikiBlockMutation) ResetField(name string) error {
	switch name {
	case wikiblock.FieldPageID:
		m.ResetPageID()
		return nil
	case wikiblock.FieldBlockType:
		m.ResetBlockType()
		return nil
	case wikiblock.FieldLevel:
		m.ResetLevel()
		return nil
	case wikiblock.FieldHeadingsPath:
		m.ResetHeadingsPath()
		return nil
	case wikiblock.FieldCanonicalJSON:
		m.ResetCanonicalJSON()
		return nil
	case wikiblock.FieldPlainText:
		m.ResetPlainText()
		return nil
	case wikiblock.FieldPosition:
		m.ResetPosition()
		return nil
	case wikiblock.FieldSearchText:
		m.ResetSearchText()
		return nil
	}
	return fmt.Errorf("unknown WikiBlock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WikiBlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.page != nil {
		edges = append(edges, wikiblock.EdgePage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WikiBlockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wikiblock.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WikiBlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WikiBlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WikiBlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpage {
		edges = append(edges, wikiblock.EdgePage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WikiBlockMutation) EdgeCleared(name string) bool {
	switch name {
	case wikiblock.EdgePage:
		return m.clearedpage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WikiBlockMutation) ClearEdge(name string) error {
	switch name {
	case wikiblock.EdgePage:
		m.ClearPage()
		return nil
	}
	return fmt.Errorf("unknown WikiBlock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WikiBlockMutation) ResetEdge(name string) error {
	switch name {
	case wikiblock.EdgePage:
		m.ResetPage()
		return nil
	}
	return fmt.Errorf("unknown WikiBlock edge %s", name)
}

// WikiPageMutation represents an operation that mutates the WikiPage nodes in the graph.
type WikiPageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	title              *string
	slug               *string
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	project            *int64
	clearedproject     bool
	creator            *int64
	clearedcreator     bool
	yjs_updates        map[int64]struct{}
	removedyjs_updates map[int64]struct{}
	clearedyjs_updates bool
	versions           map[int64]struct{}
	removedversions    map[int64]struct{}
	clearedversions    bool
	blocks             map[int64]struct{}
	removedblocks      map[int64]struct{}
	clearedblocks      bool
	done               bool
	oldValue           func(context.Context) (*WikiPage, error)
	predicates         []predicate.WikiPage
}

var _ ent.Mutation = (*WikiPageMutation)(nil)

// wikipageOption allows management of the mutation configuration using functional options.
type wikipageOption func(*WikiPageMutation)

// newWikiPageMutation creates new mutation for the WikiPage entity.
func newWikiPageMutation(c config, op Op, opts ...wikipageOption) *WikiPageMutation {
	m := &WikiPageMutation{
		config:        c,
		op:            op,
		typ:           TypeWikiPage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWikiPageID sets the ID field of the mutation.
func withWikiPageID(id int64) wikipageOption {
	return func(m *WikiPageMutation) {
		var (
			err   error
			once  sync.Once
			value *WikiPage
		)
		m.oldValue = func(ctx context.Context) (*WikiPage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WikiPage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWikiPage sets the old WikiPage of the mutation.
func withWikiPage(node *WikiPage) wikipageOption {
	return func(m *WikiPageMutation) {
		m.oldValue = func(context.Context) (*WikiPage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WikiPageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WikiPageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WikiPage entities.
func (m *WikiPageMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WikiPageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WikiPageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WikiPage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectID sets the "project_id" field.
func (m *WikiPageMutation) SetProjectID(i int64) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *WikiPageMutation) ProjectID() (r int64, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldProjectID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *WikiPageMutation) ResetProjectID() {
	m.project = nil
}

// SetTitle sets the "title" field.
func (m *WikiPageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WikiPageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *WikiPageMutation) ResetTitle() {
	m.title = nil
}

// SetSlug sets the "slug" field.
func (m *WikiPageMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *WikiPageMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ResetSlug resets all changes to the "slug" field.
func (m *WikiPageMutation) ResetSlug() {
	m.slug = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *WikiPageMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *WikiPageMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *WikiPageMutation) ResetCreatedBy() {
	m.creator = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WikiPageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WikiPageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WikiPageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WikiPageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WikiPageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WikiPage entity.
// If the WikiPage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WikiPageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WikiPageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearProject clears the "project" edge to the Project entity.
func (m *WikiPageMutation) ClearProject() {
	m.clearedproject = true
	m.clearedFields[wikipage.FieldProjectID] = struct{}{}
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *WikiPageMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *WikiPageMutation) ProjectIDs() (ids []int64) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *WikiPageMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *WikiPageMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *WikiPageMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[wikipage.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *WikiPageMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *WikiPageMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *WikiPageMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *WikiPageMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// AddYjsUpdateIDs adds the "yjs_updates" edge to the YjsUpdate entity by ids.
func (m *WikiPageMutation) AddYjsUpdateIDs(ids ...int64) {
	if m.yjs_updates == nil {
		m.yjs_updates = make(map[int64]struct{})
	}
	for i := range ids {
		m.yjs_updates[ids[i]] = struct{}{}
	}
}

// ClearYjsUpdates clears the "yjs_updates" edge to the YjsUpdate entity.
func (m *WikiPageMutation) ClearYjsUpdates() {
	m.clearedyjs_updates = true
}

// YjsUpdatesCleared reports if the "yjs_updates" edge to the YjsUpdate entity was cleared.
func (m *WikiPageMutation) YjsUpdatesCleared() bool {
	return m.clearedyjs_updates
}

// RemoveYjsUpdateIDs removes the "yjs_updates" edge to the YjsUpdate entity by IDs.
func (m *WikiPageMutation) RemoveYjsUpdateIDs(ids ...int64) {
	if m.removedyjs_updates == nil {
		m.removedyjs_updates = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.yjs_updates, ids[i])
		m.removedyjs_updates[ids[i]] = struct{}{}
	}
}

// RemovedYjsUpdates returns the removed IDs of the "yjs_updates" edge to the YjsUpdate entity.
func (m *WikiPageMutation) RemovedYjsUpdatesIDs() (ids []int64) {
	for id := range m.removedyjs_updates {
		ids = append(ids, id)
	}
	return
}

// YjsUpdatesIDs returns the "yjs_updates" edge IDs in the mutation.
func (m *WikiPageMutation) YjsUpdatesIDs() (ids []int64) {
	for id := range m.yjs_updates {
		ids = append(ids, id)
	}
	return
}

// ResetYjsUpdates resets all changes to the "yjs_updates" edge.
func (m *WikiPageMutation) ResetYjsUpdates() {
	m.yjs_updates = nil
	m.clearedyjs_updates = false
	m.removedyjs_updates = nil
}

// AddVersionIDs adds the "versions" edge to the PageVersion entity by ids.
func (m *WikiPageMutation) AddVersionIDs(ids ...int64) {
	if m.versions == nil {
		m.versions = make(map[int64]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the PageVersion entity.
func (m *WikiPageMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the PageVersion entity was cleared.
func (m *WikiPageMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the PageVersion entity by IDs.
func (m *WikiPageMutation) RemoveVersionIDs(ids ...int64) {
	if m.removedversions == nil {
		m.removedversions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the PageVersion entity.
func (m *WikiPageMutation) RemovedVersionsIDs() (ids []int64) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *WikiPageMutation) VersionsIDs() (ids []int64) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *WikiPageMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddBlockIDs adds the "blocks" edge to the WikiBlock entity by ids.
func (m *WikiPageMutation) AddBlockIDs(ids ...int64) {
	if m.blocks == nil {
		m.blocks = make(map[int64]struct{})
	}
	for i := range ids {
		m.blocks[ids[i]] = struct{}{}
	}
}

// ClearBlocks clears the "blocks" edge to the WikiBlock entity.
func (m *WikiPageMutation) ClearBlocks() {
	m.clearedblocks = true
}

// BlocksCleared reports if the "blocks" edge to the WikiBlock entity was cleared.
func (m *WikiPageMutation) BlocksCleared() bool {
	return m.clearedblocks
}

// RemoveBlockIDs removes the "blocks" edge to the WikiBlock entity by IDs.
func (m *WikiPageMutation) RemoveBlockIDs(ids ...int64) {
	if m.removedblocks == nil {
		m.removedblocks = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.blocks, ids[i])
		m.removedblocks[ids[i]] = struct{}{}
	}
}

// RemovedBlocks returns the removed IDs of the "blocks" edge to the WikiBlock entity.
func (m *WikiPageMutation) RemovedBlocksIDs() (ids []int64) {
	for id := range m.removedblocks {
		ids = append(ids, id)
	}
	return
}

// BlocksIDs returns the "blocks" edge IDs in the mutation.
func (m *WikiPageMutation) BlocksIDs() (ids []int64) {
	for id := range m.blocks {
		ids = append(ids, id)
	}
	return
}

// ResetBlocks resets all changes to the "blocks" edge.
func (m *WikiPageMutation) ResetBlocks() {
	m.blocks = nil
	m.clearedblocks = false
	m.removedblocks = nil
}

// Where appends a list predicates to the WikiPageMutation builder.
func (m *WikiPageMutation) Where(ps ...predicate.WikiPage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WikiPageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WikiPageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WikiPage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WikiPageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WikiPageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WikiPage).
func (m *WikiPageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WikiPageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.project != nil {
		fields = append(fields, wikipage.FieldProjectID)
	}
	if m.title != nil {
		fields = append(fields, wikipage.FieldTitle)
	}
	if m.slug != nil {
		fields = append(fields, wikipage.FieldSlug)
	}
	if m.creator != nil {
		fields = append(fields, wikipage.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, wikipage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, wikipage.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WikiPageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case wikipage.FieldProjectID:
		return m.ProjectID()
	case wikipage.FieldTitle:
		return m.Title()
	case wikipage.FieldSlug:
		return m.Slug()
	case wikipage.FieldCreatedBy:
		return m.CreatedBy()
	case wikipage.FieldCreatedAt:
		return m.CreatedAt()
	case wikipage.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WikiPageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case wikipage.FieldProjectID:
		return m.OldProjectID(ctx)
	case wikipage.FieldTitle:
		return m.OldTitle(ctx)
	case wikipage.FieldSlug:
		return m.OldSlug(ctx)
	case wikipage.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case wikipage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case wikipage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WikiPage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WikiPageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case wikipage.FieldProjectID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case wikipage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case wikipage.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case wikipage.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case wikipage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case wikipage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WikiPage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WikiPageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WikiPageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WikiPageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WikiPage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WikiPageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WikiPageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WikiPageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WikiPage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WikiPageMutation) ResetField(name string) error {
	switch name {
	case wikipage.FieldProjectID:
		m.ResetProjectID()
		return nil
	case wikipage.FieldTitle:
		m.ResetTitle()
		return nil
	case wikipage.FieldSlug:
		m.ResetSlug()
		return nil
	case wikipage.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case wikipage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case wikipage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown WikiPage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WikiPageMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.project != nil {
		edges = append(edges, wikipage.EdgeProject)
	}
	if m.creator != nil {
		edges = append(edges, wikipage.EdgeCreator)
	}
	if m.yjs_updates != nil {
		edges = append(edges, wikipage.EdgeYjsUpdates)
	}
	if m.versions != nil {
		edges = append(edges, wikipage.EdgeVersions)
	}
	if m.blocks != nil {
		edges = append(edges, wikipage.EdgeBlocks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WikiPageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case wikipage.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case wikipage.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case wikipage.EdgeYjsUpdates:
		ids := make([]ent.Value, 0, len(m.yjs_updates))
		for id := range m.yjs_updates {
			ids = append(ids, id)
		}
		return ids
	case wikipage.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case wikipage.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.blocks))
		for id := range m.blocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WikiPageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedyjs_updates != nil {
		edges = append(edges, wikipage.EdgeYjsUpdates)
	}
	if m.removedversions != nil {
		edges = append(edges, wikipage.EdgeVersions)
	}
	if m.removedblocks != nil {
		edges = append(edges, wikipage.EdgeBlocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WikiPageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case wikipage.EdgeYjsUpdates:
		ids := make([]ent.Value, 0, len(m.removedyjs_updates))
		for id := range m.removedyjs_updates {
			ids = append(ids, id)
		}
		return ids
	case wikipage.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case wikipage.EdgeBlocks:
		ids := make([]ent.Value, 0, len(m.removedblocks))
		for id := range m.removedblocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WikiPageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedproject {
		edges = append(edges, wikipage.EdgeProject)
	}
	if m.clearedcreator {
		edges = append(edges, wikipage.EdgeCreator)
	}
	if m.clearedyjs_updates {
		edges = append(edges, wikipage.EdgeYjsUpdates)
	}
	if m.clearedversions {
		edges = append(edges, wikipage.EdgeVersions)
	}
	if m.clearedblocks {
		edges = append(edges, wikipage.EdgeBlocks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WikiPageMutation) EdgeCleared(name string) bool {
	switch name {
	case wikipage.EdgeProject:
		return m.clearedproject
	case wikipage.EdgeCreator:
		return m.clearedcreator
	case wikipage.EdgeYjsUpdates:
		return m.clearedyjs_updates
	case wikipage.EdgeVersions:
		return m.clearedversions
	case wikipage.EdgeBlocks:
		return m.clearedblocks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WikiPageMutation) ClearEdge(name string) error {
	switch name {
	case wikipage.EdgeProject:
		m.ClearProject()
		return nil
	case wikipage.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown WikiPage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WikiPageMutation) ResetEdge(name string) error {
	switch name {
	case wikipage.EdgeProject:
		m.ResetProject()
		return nil
	case wikipage.EdgeCreator:
		m.ResetCreator()
		return nil
	case wikipage.EdgeYjsUpdates:
		m.ResetYjsUpdates()
		return nil
	case wikipage.EdgeVersions:
		m.ResetVersions()
		return nil
	case wikipage.EdgeBlocks:
		m.ResetBlocks()
		return nil
	}
	return fmt.Errorf("unknown WikiPage edge %s", name)
}

// YjsUpdateMutation represents an operation that mutates the YjsUpdate nodes in the graph.
type YjsUpdateMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	update_data    *[]byte
	created_at     *time.Time
	clearedFields  map[string]struct{}
	page           *int64
	clearedpage    bool
	creator        *int64
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*YjsUpdate, error)
	predicates     []predicate.YjsUpdate
}

var _ ent.Mutation = (*YjsUpdateMutation)(nil)

// yjsupdateOption allows management of the mutation configuration using functional options.
type yjsupdateOption func(*YjsUpdateMutation)

// newYjsUpdateMutation creates new mutation for the YjsUpdate entity.
func newYjsUpdateMutation(c config, op Op, opts ...yjsupdateOption) *YjsUpdateMutation {
	m := &YjsUpdateMutation{
		config:        c,
		op:            op,
		typ:           TypeYjsUpdate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withYjsUpdateID sets the ID field of the mutation.
func withYjsUpdateID(id int64) yjsupdateOption {
	return func(m *YjsUpdateMutation) {
		var (
			err   error
			once  sync.Once
			value *YjsUpdate
		)
		m.oldValue = func(ctx context.Context) (*YjsUpdate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().YjsUpdate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withYjsUpdate sets the old YjsUpdate of the mutation.
func withYjsUpdate(node *YjsUpdate) yjsupdateOption {
	return func(m *YjsUpdateMutation) {
		m.oldValue = func(context.Context) (*YjsUpdate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m YjsUpdateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m YjsUpdateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of YjsUpdate entities.
func (m *YjsUpdateMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *YjsUpdateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *YjsUpdateMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().YjsUpdate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPageID sets the "page_id" field.
func (m *YjsUpdateMutation) SetPageID(i int64) {
	m.page = &i
}

// PageID returns the value of the "page_id" field in the mutation.
func (m *YjsUpdateMutation) PageID() (r int64, exists bool) {
	v := m.page
	if v == nil {
		return
	}
	return *v, true
}

// OldPageID returns the old "page_id" field's value of the YjsUpdate entity.
// If the YjsUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *YjsUpdateMutation) OldPageID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPageID: %w", err)
	}
	return oldValue.PageID, nil
}

// ResetPageID resets all changes to the "page_id" field.
func (m *YjsUpdateMutation) ResetPageID() {
	m.page = nil
}

// SetUpdateData sets the "update_data" field.
func (m *YjsUpdateMutation) SetUpdateData(b []byte) {
	m.update_data = &b
}

// UpdateData returns the value of the "update_data" field in the mutation.
func (m *YjsUpdateMutation) UpdateData() (r []byte, exists bool) {
	v := m.update_data
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateData returns the old "update_data" field's value of the YjsUpdate entity.
// If the YjsUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *YjsUpdateMutation) OldUpdateData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateData: %w", err)
	}
	return oldValue.UpdateData, nil
}

// ResetUpdateData resets all changes to the "update_data" field.
func (m *YjsUpdateMutation) ResetUpdateData() {
	m.update_data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *YjsUpdateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *YjsUpdateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the YjsUpdate entity.
// If the YjsUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *YjsUpdateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *YjsUpdateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *YjsUpdateMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *YjsUpdateMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the YjsUpdate entity.
// If the YjsUpdate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *YjsUpdateMutation) OldCreatedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *YjsUpdateMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[yjsupdate.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *YjsUpdateMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[yjsupdate.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *YjsUpdateMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, yjsupdate.FieldCreatedBy)
}

// ClearPage clears the "page" edge to the WikiPage entity.
func (m *YjsUpdateMutation) ClearPage() {
	m.clearedpage = true
	m.clearedFields[yjsupdate.FieldPageID] = struct{}{}
}

// PageCleared reports if the "page" edge to the WikiPage entity was cleared.
func (m *YjsUpdateMutation) PageCleared() bool {
	return m.clearedpage
}

// PageIDs returns the "page" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PageID instead. It exists only for internal usage by the builders.
func (m *YjsUpdateMutation) PageIDs() (ids []int64) {
	if id := m.page; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPage resets all changes to the "page" edge.
func (m *YjsUpdateMutation) ResetPage() {
	m.page = nil
	m.clearedpage = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *YjsUpdateMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *YjsUpdateMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[yjsupdate.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *YjsUpdateMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *YjsUpdateMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *YjsUpdateMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *YjsUpdateMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the YjsUpdateMutation builder.
func (m *YjsUpdateMutation) Where(ps ...predicate.YjsUpdate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the YjsUpdateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *YjsUpdateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.YjsUpdate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *YjsUpdateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *YjsUpdateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (YjsUpdate).
func (m *YjsUpdateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *YjsUpdateMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.page != nil {
		fields = append(fields, yjsupdate.FieldPageID)
	}
	if m.update_data != nil {
		fields = append(fields, yjsupdate.FieldUpdateData)
	}
	if m.created_at != nil {
		fields = append(fields, yjsupdate.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, yjsupdate.FieldCreatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *YjsUpdateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case yjsupdate.FieldPageID:
		return m.PageID()
	case yjsupdate.FieldUpdateData:
		return m.UpdateData()
	case yjsupdate.FieldCreatedAt:
		return m.CreatedAt()
	case yjsupdate.FieldCreatedBy:
		return m.CreatedBy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *YjsUpdateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case yjsupdate.FieldPageID:
		return m.OldPageID(ctx)
	case yjsupdate.FieldUpdateData:
		return m.OldUpdateData(ctx)
	case yjsupdate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case yjsupdate.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	}
	return nil, fmt.Errorf("unknown YjsUpdate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *YjsUpdateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case yjsupdate.FieldPageID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPageID(v)
		return nil
	case yjsupdate.FieldUpdateData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateData(v)
		return nil
	case yjsupdate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case yjsupdate.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown YjsUpdate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *YjsUpdateMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *YjsUpdateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *YjsUpdateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown YjsUpdate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *YjsUpdateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(yjsupdate.FieldCreatedBy) {
		fields = append(fields, yjsupdate.FieldCreatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *YjsUpdateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *YjsUpdateMutation) ClearField(name string) error {
	switch name {
	case yjsupdate.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown YjsUpdate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *YjsUpdateMutation) ResetField(name string) error {
	switch name {
	case yjsupdate.FieldPageID:
		m.ResetPageID()
		return nil
	case yjsupdate.FieldUpdateData:
		m.ResetUpdateData()
		return nil
	case yjsupdate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case yjsupdate.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	}
	return fmt.Errorf("unknown YjsUpdate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *YjsUpdateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.page != nil {
		edges = append(edges, yjsupdate.EdgePage)
	}
	if m.creator != nil {
		edges = append(edges, yjsupdate.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *YjsUpdateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case yjsupdate.EdgePage:
		if id := m.page; id != nil {
			return []ent.Value{*id}
		}
	case yjsupdate.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *YjsUpdateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *YjsUpdateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *YjsUpdateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpage {
		edges = append(edges, yjsupdate.EdgePage)
	}
	if m.clearedcreator {
		edges = append(edges, yjsupdate.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *YjsUpdateMutation) EdgeCleared(name string) bool {
	switch name {
	case yjsupdate.EdgePage:
		return m.clearedpage
	case yjsupdate.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *YjsUpdateMutation) ClearEdge(name string) error {
	switch name {
	case yjsupdate.EdgePage:
		m.ClearPage()
		return nil
	case yjsupdate.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown YjsUpdate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *YjsUpdateMutation) ResetEdge(name string) error {
	switch name {
	case yjsupdate.EdgePage:
		m.ResetPage()
		return nil
	case yjsupdate.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown YjsUpdate edge %s", name)
}
